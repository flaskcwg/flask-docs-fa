# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets
# This file is distributed under the same license as the Flask package.
# Komeil Parseh  <ahmdparsh129@gmail.com>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: Flask 2.1.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-07 17:01+0430\n"
"PO-Revision-Date: 2022-06-17 12:39+0430\n"
"Last-Translator: Komeil Parseh <ahmdparsh129@gmail.com>\n"
"Language-Team: fa <ahmdparsh129@gmail.com>\n"
"Language: fa\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../quickstart.rst:2
msgid "Quickstart"
msgstr "شروع سریع"

#: ../../quickstart.rst:4
msgid ""
"Eager to get started? This page gives a good introduction to Flask. Follow :doc:"
"`installation` to set up a project and install Flask first."
msgstr ""
"مشتاق شروع هستید؟ این صفحه اطلاعات خوبی درباره فلاسک می‌دهد. برای راه‌اندازی یک "
"پروژه و نصب فلاسک، ابتدا :doc:`installation` را بررسی کنید."

#: ../../quickstart.rst:9
msgid "A Minimal Application"
msgstr "یک برنامه ساده"

#: ../../quickstart.rst:11
msgid "A minimal Flask application looks something like this:"
msgstr "یک برنامه ساده فلاسک، چیزی شبیه به این است:"

#: ../../quickstart.rst:23
msgid "So what did that code do?"
msgstr "این کد چه کاری می‌کند؟"

#: ../../quickstart.rst:25
msgid ""
"First we imported the :class:`~flask.Flask` class. An instance of this class "
"will be our WSGI application."
msgstr ""
"ابتدا کلاس :class:`~flask.Flask` را وارد کردیم. یک نمونه کلاس در برنامه WSGI ما "
"اینگونه خواهد بود."

#: ../../quickstart.rst:27
msgid ""
"Next we create an instance of this class. The first argument is the name of the "
"application's module or package. ``__name__`` is a convenient shortcut for this "
"that is appropriate for most cases. This is needed so that Flask knows where to "
"look for resources such as templates and static files."
msgstr ""
"بعد، یک نمونه از این کلاس ایجاد می کنیم. اولین آرگومان نام ماژول یا بسته برنامه "
"است. ``__name__`` میانبر مناسبی برای این کار است و در اکثر موارد مناسب است. این "
"آرگومان اجباری است چون باید فلاسک بداند که کجا به دنبال منابعی مانند قالب ها و "
"فایل های استاتیک باشد."

#: ../../quickstart.rst:32
msgid ""
"We then use the :meth:`~flask.Flask.route` decorator to tell Flask what URL "
"should trigger our function."
msgstr ""
"سپس از دکوراتور :meth:`~flask.Flask.route` استفاده می کنیم تا به فلاسک بگوییم چه "
"URL ی باید عملکرد ما را راه اندازی کند."

#: ../../quickstart.rst:34
msgid ""
"The function returns the message we want to display in the user's browser. The "
"default content type is HTML, so HTML in the string will be rendered by the "
"browser."
msgstr ""
"تابع پیامی را که می خواهیم در مرورگر کاربر نمایش دهیم برمی گرداند. نوع محتوای "
"پیش فرض HTML است، بنابراین کد HTML در رشته، توسط مرورگر ارائه می شود."

#: ../../quickstart.rst:38
msgid ""
"Save it as :file:`hello.py` or something similar. Make sure to not call your "
"application :file:`flask.py` because this would conflict with Flask itself."
msgstr ""
"آن را به صورت :file:`hello.py` یا هر چیز مشابه دیگر ذخیره کنید. مطمئن شوید که "
"برنامه خود را :file:`flask.py` نام گذاری نکنید زیرا با خود فلاسک در تضاد است."

#: ../../quickstart.rst:42
msgid ""
"To run the application, use the :command:`flask` command or :command:`python -m "
"flask`. Before you can do that you need to tell your terminal the application to "
"work with by exporting the ``FLASK_APP`` environment variable:"
msgstr ""
"برای اجرای برنامه، از دستور :command:`flask` یا :command:`python -m flask` "
"استفاده کنید. قبل از اینکه این کار را انجام دهید، باید به ترمینال خود بگویید که "
"متغیر محیطی ``FLASK_APP`` را صادر کند تا برنامه با آن کار کند:"

#: ../../quickstart.rst:49 ../../quickstart.rst:170
msgid "Bash"
msgstr "Bash"

#: ../../quickstart.rst:57 ../../quickstart.rst:177
msgid "Fish"
msgstr "Fish"

#: ../../quickstart.rst:65 ../../quickstart.rst:184
msgid "CMD"
msgstr "CMD"

#: ../../quickstart.rst:73 ../../quickstart.rst:191
msgid "Powershell"
msgstr "Powershell"

#: ../../quickstart.rst:81
msgid "Application Discovery Behavior"
msgstr "رفتار کشف برنامه"

#: ../../quickstart.rst:83
msgid ""
"As a shortcut, if the file is named ``app.py`` or ``wsgi.py``, you don't have to "
"set the ``FLASK_APP`` environment variable. See :doc:`/cli` for more details."
msgstr ""
"به عنوان راه میانبر، اگر نام فایل ``app.py`` یا ``wsgi.py`` باشد، لازم نیست "
"متغیر محیطی ``FLASK_APP`` را تنظیم کنید. برای جزئیات بیشتر به :doc:`/cli` مراجعه "
"کنید."

#: ../../quickstart.rst:87
msgid ""
"This launches a very simple builtin server, which is good enough for testing but "
"probably not what you want to use in production. For deployment options see :doc:"
"`deploying/index`."
msgstr ""
"این یک سرور داخلی بسیار ساده را راه اندازی می کند که برای آزمایش به اندازه کافی "
"خوب است اما احتمالاً آن چیزی نیست که می خواهید در تولید استفاده کنید. برای گزینه "
"های استقرار به :doc:`deploying/index` مراجعه کنید."

#: ../../quickstart.rst:91
msgid ""
"Now head over to http://127.0.0.1:5000/, and you should see your hello world "
"greeting."
msgstr "اکنون به http://127.0.0.1:5000/ بروید، و باید سلام جهان را ببینید."

#: ../../quickstart.rst:94
msgid ""
"If another program is already using port 5000, you'll see ``OSError: [Errno "
"98]`` or ``OSError: [WinError 10013]`` when the server tries to start. See :ref:"
"`address-already-in-use` for how to handle that."
msgstr ""
"اگر برنامه دیگری در حال حاضر از پورت 5000 استفاده می کند، زمانی که سرور تلاش می "
"کند راه اندازی شود، ``OSError: [WinError 10013]`` یا ``OSError: [Errno 98]`` را "
"مشاهده خواهید کرد. برای نحوه رسیدگی به آن به :ref:`address-already-in-use` "
"مراجعه کنید."

#: ../../quickstart.rst:101
msgid "Externally Visible Server"
msgstr "سرور قابل مشاهده خارجی"

#: ../../quickstart.rst:103
msgid ""
"If you run the server you will notice that the server is only accessible from "
"your own computer, not from any other in the network.  This is the default "
"because in debugging mode a user of the application can execute arbitrary Python "
"code on your computer."
msgstr ""
"اگر سرور را اجرا کنید، متوجه خواهید شد که سرور فقط از طریق رایانه شخصی شما قابل "
"دسترسی است، نه از هیچ رایانه دیگری در شبکه. این پیش‌فرض است زیرا در حالت "
"اشکال‌زدایی، کاربر برنامه می‌تواند کد پایتون دلخواه را روی رایانه شما اجرا کند."

#: ../../quickstart.rst:108
msgid ""
"If you have the debugger disabled or trust the users on your network, you can "
"make the server publicly available simply by adding ``--host=0.0.0.0`` to the "
"command line::"
msgstr ""
"اگر دیباگر را غیرفعال کرده اید یا به کاربران شبکه خود اعتماد دارید، می توانید "
"سرور را به سادگی با افزودن ``--host=0.0.0.0`` به خط فرمان در دسترس عموم قرار "
"دهید:"

#: ../../quickstart.rst:114
msgid "This tells your operating system to listen on all public IPs."
msgstr "این به سیستم عامل شما می گوید که به تمام IP های عمومی گوش دهد."

#: ../../quickstart.rst:118
msgid "What to do if the Server does not Start"
msgstr "اگر سرور راه اندازی نشد چه باید کرد"

#: ../../quickstart.rst:120
msgid ""
"In case the :command:`python -m flask` fails or :command:`flask` does not exist, "
"there are multiple reasons this might be the case. First of all you need to look "
"at the error message."
msgstr ""
"در صورتی که :command:`python -m flask` از کار بیفتد یا :command:`flask` وجود "
"نداشته باشد، دلایل متعددی ممکن است وجود داشته باشد. اول از همه باید به پیام خطا "
"نگاه کنید."

#: ../../quickstart.rst:125
msgid "Old Version of Flask"
msgstr "نسخه قدیمی فلاسک"

#: ../../quickstart.rst:127
msgid ""
"Versions of Flask older than 0.11 used to have different ways to start the "
"application.  In short, the :command:`flask` command did not exist, and neither "
"did :command:`python -m flask`.  In that case you have two options: either "
"upgrade to newer Flask versions or have a look at :doc:`/server` to see the "
"alternative method for running a server."
msgstr ""
"در نسخه های ۰.۱۱ و قبل از آن تفاوتی در اجرای برنامه بود. به صورت کوتاه، :command:"
"`flask` و :command:`python -m flask` وجود خارجی نداشتند. در این حالت شما دو "
"انتخاب داشتید: یا فلاسک را به نسخه های جدیدتر بروز کنید یا :doc:`/server` را "
"بررسی می کردید تا روشی تناوبی برای اجرای سرور بیابید."

#: ../../quickstart.rst:134
msgid "Invalid Import Name"
msgstr "وارد کردن اسم نامعتبر"

#: ../../quickstart.rst:136
msgid ""
"The ``FLASK_APP`` environment variable is the name of the module to import at :"
"command:`flask run`. In case that module is incorrectly named you will get an "
"import error upon start (or if debug is enabled when you navigate to the "
"application). It will tell you what it tried to import and why it failed."
msgstr ""
"متغیر محیطی ``FLASK_APP`` نام ماژولی است که باید در :command:`flask run` وارد "
"شود. در صورتی که نام آن ماژول اشتباه باشد، هنگام شروع با خطای وارد کردن مواجه "
"خواهید شد (یا اگر هنگام رفتن به برنامه، اشکال زدایی فعال باشد). به شما می گوید "
"که چه چیزی را وارد کرده و چرا شکست خورده است."

#: ../../quickstart.rst:141
msgid ""
"The most common reason is a typo or because you did not actually create an "
"``app`` object."
msgstr ""
"رایج‌ترین دلیل اشتباه تایپی است یا اینکه شما واقعاً یک شی ``app`` ایجاد نکرده‌اید."

#: ../../quickstart.rst:146
msgid "Debug Mode"
msgstr "حالت اشکال زدایی"

#: ../../quickstart.rst:148
msgid ""
"The ``flask run`` command can do more than just start the development server. By "
"enabling debug mode, the server will automatically reload if code changes, and "
"will show an interactive debugger in the browser if an error occurs during a "
"request."
msgstr ""
"دستور ``flask run`` میتواند کار های بیشتری از توسعه سرور انجام دهد. با فعال سازی "
"حالت اشکال زدایی سرور درصورت تغییر کد به صورت خودکار باز راه‌اندازی میشود و در "
"صورت بروز خطا در هنگام درخواست، یک دیباگر تعاملی را در مرورگر نشان می دهد."

#: ../../quickstart.rst:160
msgid ""
"The debugger allows executing arbitrary Python code from the browser. It is "
"protected by a pin, but still represents a major security risk. Do not run the "
"development server or debugger in a production environment."
msgstr ""
"دیباگر اجازه می دهد تا کد پایتون دلخواه را از مرورگر اجرا کنید. توسط یک پین "
"محافظت می شود، اما همچنان یک خطر امنیتی بزرگ است. سرور توسعه یا دیباگر را در "
"محیط تولید اجرا نکنید."

#: ../../quickstart.rst:165
msgid ""
"To enable all development features, set the ``FLASK_ENV`` environment variable "
"to ``development`` before calling ``flask run``."
msgstr ""
"برای فعال سازی تمام قابلیت های توسعه، قبل از اجرای ``flask run`` ، متغیر محیطی "
"``FLASK_ENV`` را برابر ``development`` قرار دهید."

#: ../../quickstart.rst:198
msgid "See also:"
msgstr "همچنین ببینید:"

#: ../../quickstart.rst:200
msgid ""
":doc:`/server` and :doc:`/cli` for information about running in development mode."
msgstr ""
"برای اطلاعات درباره اجرا در حالت توسعه :doc:`/server` و :doc:`/cli` را ببینید."

#: ../../quickstart.rst:202
msgid ""
":doc:`/debugging` for information about using the built-in debugger and other "
"debuggers."
msgstr ""
"برای اطلاعات درباره دیباگر داخلی و سایر دیباگر ها :doc:`/debugging` ببینید."

#: ../../quickstart.rst:204
msgid ""
":doc:`/logging` and :doc:`/errorhandling` to log errors and display nice error "
"pages."
msgstr ""
":doc:`/logging` و :doc:`/errorhandling` را برای لاگ های ارور و نمایش بهتر صفحات "
"ارور ببینید."

#: ../../quickstart.rst:209
msgid "HTML Escaping"
msgstr "فرار HTML (HTML Escaping)"

# مقاوم:escape
#: ../../quickstart.rst:211
msgid ""
"When returning HTML (the default response type in Flask), any user-provided "
"values rendered in the output must be escaped to protect from injection attacks. "
"HTML templates rendered with Jinja, introduced later, will do this automatically."
msgstr ""
"هنگام برگرداندن HTML (نوع پاسخ پیش‌فرض در فلاسک)، هر مقدار ارائه‌شده توسط کاربر که "
"در خروجی ارائه می‌شود، باید برای محافظت در برابر حملات XSS مقاوم باشند. قالب‌های "
"HTML ارائه‌شده با Jinja، که بعداً معرفی شدند، این کار را به‌طور خودکار انجام می‌دهند."

#: ../../quickstart.rst:216
msgid ""
":func:`~markupsafe.escape`, shown here, can be used manually. It is omitted in "
"most examples for brevity, but you should always be aware of how you're using "
"untrusted data."
msgstr ""
"تابع :func:`~markupsafe.escape`، که در اینجا نشان داده شده است، می تواند به صورت "
"دستی استفاده شود. در بیشتر نمونه ها برای اختصار از آن حذف شده است، اما همیشه "
"باید از نحوه استفاده از داده های نامعتبر آگاه باشید."

# escape:فرار
#: ../../quickstart.rst:228
msgid ""
"If a user managed to submit the name ``<script>alert(\"bad\")</script>``, "
"escaping causes it to be rendered as text, rather than running the script in the "
"user's browser."
msgstr ""
"اگر کاربر موفق به ارسال ``<script>alert(\"bad\")</script>`` شود، فرار باعث می "
"شود که به جای اجرای اسکریپت در مرورگر کاربر، به صورت متن ارائه شود."

#: ../../quickstart.rst:232
msgid ""
"``<name>`` in the route captures a value from the URL and passes it to the view "
"function. These variable rules are explained below."
msgstr ""
"``<name>`` در مسیر یک مقدار از URL گرفته و به تابع view ارسال می کند. این قوانین "
"متغیر در زیر توضیح داده شده است."

#: ../../quickstart.rst:237
msgid "Routing"
msgstr "مسیریابی"

#: ../../quickstart.rst:239
msgid ""
"Modern web applications use meaningful URLs to help users. Users are more likely "
"to like a page and come back if the page uses a meaningful URL they can remember "
"and use to directly visit a page."
msgstr ""
"برنامه های وب مدرن از URL های معنی دار برای کمک به کاربران استفاده می کنند. اگر "
"کاربران یک صفحه را دوست داشته باشند و اگر صفحه از URL معنی‌داری استفاده کند، "
"کاربران می‌توانند URL را به خاطر بسپارند و مستقیماً از صفحه بازدید کنند."

#: ../../quickstart.rst:243
msgid ""
"Use the :meth:`~flask.Flask.route` decorator to bind a function to a URL. ::"
msgstr ""
"از دکوراتور :meth:`~flask.Flask.route` برای اتصال یک تابع به URL استفاده کنید. ::"

#: ../../quickstart.rst:253
msgid ""
"You can do more! You can make parts of the URL dynamic and attach multiple rules "
"to a function."
msgstr ""
"شما میتوانید کار های زیادی را انجام دهید! میتوانید بخشی از URL را پویا کنید و "
"چند قانون به تابع اضافه کنید."

#: ../../quickstart.rst:257
msgid "Variable Rules"
msgstr "قوانین متغیر"

#: ../../quickstart.rst:259
msgid ""
"You can add variable sections to a URL by marking sections with "
"``<variable_name>``. Your function then receives the ``<variable_name>`` as a "
"keyword argument. Optionally, you can use a converter to specify the type of the "
"argument like ``<converter:variable_name>``. ::"
msgstr ""
"می‌توانید با علامت‌گذاری بخش‌ها با ``<variable_name>`` ، بخش‌هایی از متغیر را به URL "
"اضافه کنید. سپس تابع شما ``<variable_name>`` را به عنوان آرگومان کلمه کلیدی "
"دریافت می کند. به صورت اختیاری، می توانید از یک مبدل برای تعیین نوع آرگومان "
"مانند ``<converter:variable_name>`` استفاده کنید. ::"

#: ../../quickstart.rst:281
msgid "Converter types:"
msgstr "انواع مبدل:"

#: ../../quickstart.rst:284
msgid "``string``"
msgstr "``رشته``"

#: ../../quickstart.rst:284
msgid "(default) accepts any text without a slash"
msgstr "به صورت پیشفرض هر متنی را بدون اسلش می پذیرد"

#: ../../quickstart.rst:285
msgid "``int``"
msgstr "``عدد صحیح``"

#: ../../quickstart.rst:285
msgid "accepts positive integers"
msgstr "اعداد صحیح مثبت را می پذیرد"

#: ../../quickstart.rst:286
msgid "``float``"
msgstr "``عدد اعشاری``"

#: ../../quickstart.rst:286
msgid "accepts positive floating point values"
msgstr "تمام اعداد اعشاری مثبت را می پذیرد"

#: ../../quickstart.rst:287
msgid "``path``"
msgstr "``مسیر``"

#: ../../quickstart.rst:287
msgid "like ``string`` but also accepts slashes"
msgstr "مانند ``رشته`` است ولی اسلش را هم می پذیرد"

#: ../../quickstart.rst:288
msgid "``uuid``"
msgstr "``uuid``"

#: ../../quickstart.rst:288
msgid "accepts UUID strings"
msgstr "رشته های UUID را می پذیرد"

#: ../../quickstart.rst:293
msgid "Unique URLs / Redirection Behavior"
msgstr "URL های منحصر به فرد / رفتار تغییر مسیر"

#: ../../quickstart.rst:295
msgid "The following two rules differ in their use of a trailing slash. ::"
msgstr "دو قانون زیر در استفاده از اسلش انتهایی متفاوت است. ::"

#: ../../quickstart.rst:305
msgid ""
"The canonical URL for the ``projects`` endpoint has a trailing slash. It's "
"similar to a folder in a file system. If you access the URL without a trailing "
"slash (``/projects``), Flask redirects you to the canonical URL with the "
"trailing slash (``/projects/``)."
msgstr ""
"URL متعارف برای نقطه پایانی ``projects`` دارای یک اسلش انتهایی است. این شبیه به "
"یک پوشه در یک سیستم فایل است. اگر بدون اسلش انتهایی (``/projects``) به URL "
"دسترسی داشته باشید، Flask شما را به URL متعارف با اسلش انتهایی (``/projects/``) "
"هدایت می کند."

#: ../../quickstart.rst:310
msgid ""
"The canonical URL for the ``about`` endpoint does not have a trailing slash. "
"It's similar to the pathname of a file. Accessing the URL with a trailing slash "
"(``/about/``) produces a 404 \"Not Found\" error. This helps keep URLs unique "
"for these resources, which helps search engines avoid indexing the same page "
"twice."
msgstr ""
"URL متعارف برای نقطه پایانی ``about`` دارای یک اسلش انتهایی نیست. این شبیه به "
"نام مسیر یک فایل است. دسترسی به URL با اسلش انتهایی (``/about/``) باعث ایجاد "
"خطای ۴۰۴ «یافت نشد» می شود. این کمک می کند تا URL ها برای این منابع منحصر به فرد "
"باقی بمانند، که به موتورهای جستجو کمک می کند تا از نمایه سازی یک صفحه دو بار "
"جلوگیری کنند."

#: ../../quickstart.rst:320
msgid "URL Building"
msgstr "ساخت URL"

#: ../../quickstart.rst:322
msgid ""
"To build a URL to a specific function, use the :func:`~flask.url_for` function. "
"It accepts the name of the function as its first argument and any number of "
"keyword arguments, each corresponding to a variable part of the URL rule. "
"Unknown variable parts are appended to the URL as query parameters."
msgstr ""
"برای ساخت یک URL برای یک تابع خاص، از تابع :func:`~flask.url_for` استفاده کنید. "
"نام تابع را به عنوان اولین آرگومان و هر تعداد آرگومان کلمه کلیدی که هر کدام "
"مربوط به بخش متغیری از قانون URL است را می پذیرد. قسمت های متغیر ناشناخته به "
"عنوان پارامترهای پرس و جو به URL اضافه می شوند."

#: ../../quickstart.rst:327
msgid ""
"Why would you want to build URLs using the URL reversing function :func:`~flask."
"url_for` instead of hard-coding them into your templates?"
msgstr ""
"چرا می خواهید URL ها را با استفاده از تابع :func:`~flask.url_for` بسازید به جای "
"آنکه کد ها را در قالب های خود بنویسید؟"

#: ../../quickstart.rst:330
msgid "Reversing is often more descriptive than hard-coding the URLs."
msgstr "معکوس کردن اغلب توصیفی از کدگذاری سخت URL ها است."

#: ../../quickstart.rst:331
msgid ""
"You can change your URLs in one go instead of needing to remember to manually "
"change hard-coded URLs."
msgstr ""
"می‌توانید به‌جای اینکه به یاد داشته باشید که URL‌های کدگذاری‌شده را به‌صورت دستی "
"تغییر دهید، آدرس‌های اینترنتی خود را یکباره تغییر دهید."

#: ../../quickstart.rst:333
msgid "URL building handles escaping of special characters transparently."
msgstr "ساختمان فرار URL از کاراکترهای خاص را به طور شفاف کنترل می کند."

#: ../../quickstart.rst:334
msgid ""
"The generated paths are always absolute, avoiding unexpected behavior of "
"relative paths in browsers."
msgstr ""
"مسیرهای تولید شده همیشه مطلق هستند و از رفتار غیرمنتظره مسیرهای وابسته در "
"مرورگرها جلوگیری می کنند."

#: ../../quickstart.rst:336
msgid ""
"If your application is placed outside the URL root, for example, in ``/"
"myapplication`` instead of ``/``, :func:`~flask.url_for` properly handles that "
"for you."
msgstr ""
"اگر برنامه شما خارج از ریشه URL قرار داده شده است، به عنوان مثال، به جای ``/`` "
"در ``/myapplication`` باشد، :func:`~flask.url_for` به درستی آن را برای شما "
"مدیریت می کند."

#: ../../quickstart.rst:340
msgid ""
"For example, here we use the :meth:`~flask.Flask.test_request_context` method to "
"try out :func:`~flask.url_for`. :meth:`~flask.Flask.test_request_context` tells "
"Flask to behave as though it's handling a request even while we use a Python "
"shell. See :ref:`context-locals`."
msgstr ""
"به عنوان مثال، در اینجا از روش :meth:`~flask.Flask.test_request_context` برای "
"امتحان کردن :func:`~flask.url_for` استفاده می کنیم. :meth:`~flask.Flask."
"test_request_context` به فلاسک می گوید که به گونه ای رفتار کند که انگار در حال "
"رسیدگی به یک درخواست است حتی زمانی که ما از پوسته پایتون استفاده می کنیم. به :"
"ref:`context-locals` مراجعه کنید."

#: ../../quickstart.rst:376
msgid "HTTP Methods"
msgstr "متود های HTTP"

#: ../../quickstart.rst:378
msgid ""
"Web applications use different HTTP methods when accessing URLs. You should "
"familiarize yourself with the HTTP methods as you work with Flask. By default, a "
"route only answers to ``GET`` requests. You can use the ``methods`` argument of "
"the :meth:`~flask.Flask.route` decorator to handle different HTTP methods. ::"
msgstr ""
"برنامه های کاربردی وب هنگام دسترسی به URL ها از روش های مختلف HTTP استفاده می "
"کنند. هنگام کار با فلاسک باید با روش های HTTP آشنا شوید. به طور پیش‌فرض، یک مسیر "
"فقط به درخواست‌های ``GET`` پاسخ می‌دهد. می‌توانید از آرگومان``methods`` دکوراتور :"
"meth:`~flask.Flask.route` برای مدیریت روش‌های مختلف HTTP استفاده کنید. ::"

#: ../../quickstart.rst:393
msgid ""
"If ``GET`` is present, Flask automatically adds support for the ``HEAD`` method "
"and handles ``HEAD`` requests according to the `HTTP RFC`_. Likewise, "
"``OPTIONS`` is automatically implemented for you."
msgstr ""
"اگر ``GET`` وجود داشته باشد، فلاسک به طور خودکار از روش ``HEAD`` پشتیبانی می‌کند "
"و درخواست‌های «HEAD» را مطابق با `HTTP RFC`_ مدیریت می‌کند. به همین ترتیب، "
"``OPTIONS`` به طور خودکار برای شما پیاده سازی می شود."

#: ../../quickstart.rst:400
msgid "Static Files"
msgstr "فایل های استاتیک"

#: ../../quickstart.rst:402
msgid ""
"Dynamic web applications also need static files.  That's usually where the CSS "
"and JavaScript files are coming from.  Ideally your web server is configured to "
"serve them for you, but during development Flask can do that as well.  Just "
"create a folder called :file:`static` in your package or next to your module and "
"it will be available at ``/static`` on the application."
msgstr ""
"برنامه های وب پویا به فایل های استاتیک نیز نیاز دارند. معمولاً فایل های CSS و "
"جاوا اسکریپت از آنجا می آیند. در حالت ایده آل وب سرور شما به گونه ای پیکربندی "
"شده است که آنها را برای شما ارائه دهد، اما در حین توسعه، فلاسک می تواند این کار "
"را نیز انجام داد. فقط یک پوشه به نام :file:`static` در پکیج خود یا در کنار ماژول "
"خود ایجاد کنید و در آدرس ``/static`` در برنامه در دسترس خواهد بود."

# endpoint: نقطه پایانی
#: ../../quickstart.rst:408
msgid ""
"To generate URLs for static files, use the special ``'static'`` endpoint name::"
msgstr ""
"برای ایجاد URL برای فایل‌های استاتیک، از نام نقطه پایانی ویژه ``'static'`` "
"استفاده کنید::"

#: ../../quickstart.rst:412
msgid "The file has to be stored on the filesystem as :file:`static/style.css`."
msgstr "فایل باید در سیستم فایل به صورت :file:`static/style.css` ذخیره شود."

#: ../../quickstart.rst:415
msgid "Rendering Templates"
msgstr "الگوهای رندرینگ"

#: ../../quickstart.rst:417
msgid ""
"Generating HTML from within Python is not fun, and actually pretty cumbersome "
"because you have to do the HTML escaping on your own to keep the application "
"secure.  Because of that Flask configures the `Jinja2 <https://palletsprojects."
"com/p/jinja/>`_ template engine for you automatically."
msgstr ""
"تولید HTML از داخل پایتون سرگرم کننده نیست، و در واقع بسیار دست و پا گیر است، "
"زیرا برای ایمن نگه داشتن برنامه، باید HTML را به تنهایی انجام دهید. به همین دلیل "
"فلاسک موتور قالب `Jinja2 <https://palletsprojects.com/p/jinja/>`_ را به طور "
"خودکار برای شما پیکربندی می کند."

#: ../../quickstart.rst:422
msgid ""
"To render a template you can use the :func:`~flask.render_template` method.  All "
"you have to do is provide the name of the template and the variables you want to "
"pass to the template engine as keyword arguments. Here's a simple example of how "
"to render a template::"
msgstr ""
"برای رندر یک الگو می توانید از روش :func:`~flask.render_template` استفاده کنید. "
"تنها کاری که باید انجام دهید این است که نام قالب و متغیرهایی را که می خواهید به "
"عنوان آرگومان های کلمه کلیدی به موتور قالب منتقل کنید، ارائه دهید. در اینجا یک "
"مثال ساده از نحوه ارائه یک الگو آورده شده است:"

#: ../../quickstart.rst:434
msgid ""
"Flask will look for templates in the :file:`templates` folder.  So if your "
"application is a module, this folder is next to that module, if it's a package "
"it's actually inside your package:"
msgstr ""
"فلاسک دارای مقادیر زیادی از پیکربندی با پیش فرض های معقول، و چند قرارداد در "
"هنگام شروع است. طبق قرارداد، قالب‌ها و فایل‌های استاتیک در زیرشاخه‌های منبع برنامه، "
"با نام‌ های :file:`templates` و :file:`static` ذخیره می‌شوند. البته میتوان آنها را "
"تغییر داد ولی معمولا به خصوص در هنگام شروع مجبور نیستید که آنها را تغییر دهید:"

#: ../../quickstart.rst:438
msgid "**Case 1**: a module::"
msgstr "**مورد ۱**: یک ماژول::"

#: ../../quickstart.rst:444
msgid "**Case 2**: a package::"
msgstr "**مورد ۲**: یک ماژول::"

#: ../../quickstart.rst:451
msgid ""
"For templates you can use the full power of Jinja2 templates.  Head over to the "
"official `Jinja2 Template Documentation <https://jinja.palletsprojects.com/"
"templates/>`_ for more information."
msgstr ""
"برای قالب ها می توانید از قدرت کامل قالب های Jinja2 استفاده کنید. برای اطلاعات "
"بیشتر به `مستندات الگوی jinja2 <https://jinja.palletsprojects.com/templates/>`_ "
"مراجعه کنید."

#: ../../quickstart.rst:455
msgid "Here is an example template:"
msgstr "اینجا یک مثال برای قالب است:"

#: ../../quickstart.rst:467
msgid ""
"Inside templates you also have access to the :data:`~flask.Flask.config`, :class:"
"`~flask.request`, :class:`~flask.session` and :class:`~flask.g` [#]_ objects as "
"well as the :func:`~flask.url_for` and :func:`~flask.get_flashed_messages` "
"functions."
msgstr ""
"در داخل الگوها همچنین به :data:`~flask.Flask.config`, :class:`~flask.request`, :"
"class:`~flask.session` و :class:`~flask.g` [#]_  و همچنین به توابع :func:`~flask."
"url_for`  و :func:`~flask.get_flashed_messages` دسترسی دارید."

#: ../../quickstart.rst:471
msgid ""
"Templates are especially useful if inheritance is used.  If you want to know how "
"that works, see :doc:`patterns/templateinheritance`. Basically template "
"inheritance makes it possible to keep certain elements on each page (like "
"header, navigation and footer)."
msgstr ""
"اگر از وراثت استفاده میکنید.، الگوها بسیار مفید هستند. اگر می خواهید بدانید که "
"چگونه کار می کند، به :doc:`patterns/templateinheritance` مراجعه کنید. اساساً، "
"وراثت قالب، نگه داشتن عناصر خاصی را در هر صفحه (مانند هدر، ناوبری و پاورقی) ممکن "
"می‌سازد."

# خنثی:escape
#: ../../quickstart.rst:476
msgid ""
"Automatic escaping is enabled, so if ``name`` contains HTML it will be escaped "
"automatically.  If you can trust a variable and you know that it will be safe "
"HTML (for example because it came from a module that converts wiki markup to "
"HTML) you can mark it as safe by using the :class:`~markupsafe.Markup` class or "
"by using the ``|safe`` filter in the template.  Head over to the Jinja 2 "
"documentation for more examples."
msgstr ""
"فرار خودکار فعال است، بنابراین اگر ``name`` حاوی HTML باشد، به طور خودکار از آن "
"خنثی میکند. اگر می‌توانید به متغیری اعتماد کنید و می‌دانید که HTML ایمن خواهد بود "
"(مثلاً چون از ماژولی است که نشانه‌گذاری ویکی را به HTML تبدیل می‌کند)، می‌توانید با "
"استفاده از کلاس :class:`~markupsafe.Markup`  آن را به عنوان امن علامت‌گذاری کنید. "
"یا با استفاده از فیلتر ``|safe`` در الگو اینکار را انجام دهید. برای نمونه های "
"بیشتر به مستندات Jinja 2 بروید."

#: ../../quickstart.rst:483
msgid ""
"Here is a basic introduction to how the :class:`~markupsafe.Markup` class works::"
msgstr ""
"در اینجا یک مقدمه اولیه برای نحوه عملکرد کلاس :class:`~markupsafe.Markup` آورده "
"شده است::"

# فرارخودکار:autoescaping
#: ../../quickstart.rst:495
msgid ""
"Autoescaping is no longer enabled for all templates.  The following extensions "
"for templates trigger autoescaping: ``.html``, ``.htm``, ``.xml``, ``.xhtml``.  "
"Templates loaded from a string will have autoescaping disabled."
msgstr ""
"فرار خودکار دیگر برای همه الگوها فعال نیست. فرار خودکار برای پسوند های زیر انجام "
"میشود: : ``.html``, ``.htm``, ``.xml``, ``.xhtml``. الگوهای بارگذاری شده از یک "
"رشته، فرار خودکار را غیر فعال خواهد کرد."

#: ../../quickstart.rst:500
msgid ""
"Unsure what that :class:`~flask.g` object is? It's something in which you can "
"store information for your own needs. See the documentation for :class:`flask.g` "
"and :doc:`patterns/sqlite3`."
msgstr ""
"اطمینان ندارید که شی :class:`~flask.g` چیست؟ این چیزی است که در آن می توانید "
"اطلاعات را برای نیازهای خود ذخیره کنید. برای اطلاعات بیشتر به مستندات :class:"
"`flask.g` و :doc:`patterns/sqlite3` مراجعه کنید."

#: ../../quickstart.rst:506
msgid "Accessing Request Data"
msgstr "دسترسی به داده های درخواستی"

#: ../../quickstart.rst:508
msgid ""
"For web applications it's crucial to react to the data a client sends to the "
"server.  In Flask this information is provided by the global :class:`~flask."
"request` object.  If you have some experience with Python you might be wondering "
"how that object can be global and how Flask manages to still be threadsafe.  The "
"answer is context locals:"
msgstr ""
"برای برنامه های کاربردی وب، بسیار مهم است که به داده هایی که مشتری به سرور ارسال "
"می کند واکنش نشان دهد. در فلاسک این اطلاعات توسط شیء سراسری :class:`~flask."
"request` ارائه می شود. اگر تجربه‌ای با پایتون دارید، ممکن است تعجب کنید که چگونه "
"آن شی می‌تواند سراسری باشد و چگونه فلاسک می‌تواند همچنان امن باشد. پاسخ متن محلی "
"است:"

#: ../../quickstart.rst:518
msgid "Context Locals"
msgstr "متن محلی"

#: ../../quickstart.rst:520
msgid "Insider Information"
msgstr "اطلاعات داخلی"

#: ../../quickstart.rst:522
msgid ""
"If you want to understand how that works and how you can implement tests with "
"context locals, read this section, otherwise just skip it."
msgstr ""
"اگر می‌خواهید بدانید که چگونه کار می‌کند و چگونه می‌توانید آزمایش‌ها را با متن محلی "
"پیاده‌سازی کنید، این بخش را بخوانید، در غیر این صورت فقط آن را نادیده بگیرید."

#: ../../quickstart.rst:525
msgid ""
"Certain objects in Flask are global objects, but not of the usual kind. These "
"objects are actually proxies to objects that are local to a specific context.  "
"What a mouthful.  But that is actually quite easy to understand."
msgstr ""
"برخی از اشیاء در فلاسک، اشیاء جهانی هستند، اما از نوع معمول نیستند. این اشیاء "
"پروکسی برای اشیایی هستند که محلی برای یک زمینه خاص هستند. اما درک آن بسیار آسان "
"است."

#: ../../quickstart.rst:529
msgid ""
"Imagine the context being the handling thread.  A request comes in and the web "
"server decides to spawn a new thread (or something else, the underlying object "
"is capable of dealing with concurrency systems other than threads).  When Flask "
"starts its internal request handling it figures out that the current thread is "
"the active context and binds the current application and the WSGI environments "
"to that context (thread). It does that in an intelligent way so that one "
"application can invoke another application without breaking."
msgstr ""
"تصور کنید که زمینه، موضوع مدیریت است. یک درخواست وارد می‌شود و وب‌سرور تصمیم "
"می‌گیرد یک رشته جدید ایجاد کند (یا چیز دیگری، شی زیربنایی قادر است با سیستم‌ های "
"همزمانی غیر از رشته‌ها سروکار داشته باشد). هنگامی که فلاسک رسیدگی به درخواست "
"داخلی خود را شروع می کند، متوجه می شود که رشته فعلی زمینه فعال است و برنامه فعلی "
"و محیط های WSGI را به آن زمینه (رشته) متصل می کند. این کار را به روشی هوشمند "
"انجام می دهد تا یک برنامه بتواند برنامه دیگری را بدون شکستن فراخوانی کند."

#: ../../quickstart.rst:538
msgid ""
"So what does this mean to you?  Basically you can completely ignore that this is "
"the case unless you are doing something like unit testing.  You will notice that "
"code which depends on a request object will suddenly break because there is no "
"request object.  The solution is creating a request object yourself and binding "
"it to the context.  The easiest solution for unit testing is to use the :meth:"
"`~flask.Flask.test_request_context` context manager.  In combination with the "
"``with`` statement it will bind a test request so that you can interact with "
"it.  Here is an example::"
msgstr ""
"پس این برای شما چه معنی دارد؟ اساساً می توانید کاملاً نادیده بگیرید که این مورد "
"است مگر اینکه در حال انجام کاری مانند تست واحد باشید. متوجه خواهید شد که کدی که "
"به یک شی درخواست بستگی دارد ناگهان شکسته می شود زیرا شی درخواستی وجود ندارد. راه "
"حل این است که خودتان یک شی درخواست ایجاد کنید و آن را به متن متصل کنید. ساده "
"ترین راه حل برای تست واحد استفاده از مدیر زمینه :meth:`~flask.Flask."
"test_request_context` است. در ترکیب با عبارت ``with`` یک درخواست آزمایشی را متصل "
"می کند تا بتوانید با آن تعامل داشته باشید. به عنوان مثال::"

#: ../../quickstart.rst:555
msgid ""
"The other possibility is passing a whole WSGI environment to the :meth:`~flask."
"Flask.request_context` method::"
msgstr ""
"امکان دیگر ارسال یک محیط WSGI کامل به متد :meth:`~flask.Flask.request_context` "
"method::"

#: ../../quickstart.rst:562
msgid "The Request Object"
msgstr "شی درخواست"

#: ../../quickstart.rst:564
msgid ""
"The request object is documented in the API section and we will not cover it "
"here in detail (see :class:`~flask.Request`). Here is a broad overview of some "
"of the most common operations.  First of all you have to import it from the "
"``flask`` module::"
msgstr ""
"شی درخواست در بخش API مستند شده است و ما در اینجا آن را با جزئیات پوشش نمی دهیم "
"(به :class:`~flask.Request` مراجعه کنید). در اینجا یک مرور کلی از برخی از رایج "
"ترین عملیات ارائه شده است. اول از همه، شما باید آن را از ماژول ``flask`` وارد "
"کنید::"

#: ../../quickstart.rst:571
msgid ""
"The current request method is available by using the :attr:`~flask.Request."
"method` attribute.  To access form data (data transmitted in a ``POST`` or "
"``PUT`` request) you can use the :attr:`~flask.Request.form` attribute.  Here is "
"a full example of the two attributes mentioned above::"
msgstr ""
"روش درخواست فعلی با استفاده از ویژگی :attr:`~flask.Request.method` در دسترس است. "
"برای دسترسی به داده‌های فرم (داده‌های ارسال شده در درخواست ``POST``  یا ``PUT``) "
"می‌توانید از ویژگی :attr:`~flask.Request.form` استفاده کنید. در اینجا یک مثال "
"کامل از دو ویژگی ذکر شده در بالا آورده شده است::"

#: ../../quickstart.rst:590
msgid ""
"What happens if the key does not exist in the ``form`` attribute?  In that case "
"a special :exc:`KeyError` is raised.  You can catch it like a standard :exc:"
"`KeyError` but if you don't do that, a HTTP 400 Bad Request error page is shown "
"instead.  So for many situations you don't have to deal with that problem."
msgstr ""
"اگر کلید در ویژگی ``form`` وجود نداشته باشد چه اتفاقی می افتد؟ در آن صورت، یک :"
"exc:`KeyError` ویژه ایجاد می شود. می‌توانید آن را مانند یک :exc:`KeyError` "
"استاندارد دریافت کنید، اما اگر این کار را نکنید، یک صفحه خطای درخواست بد HTTP "
"400 نشان داده می‌شود. بنابراین برای بسیاری از موقعیت ها، لازم نیست با آن مشکل "
"کنار بیایید."

#: ../../quickstart.rst:596
msgid ""
"To access parameters submitted in the URL (``?key=value``) you can use the :attr:"
"`~flask.Request.args` attribute::"
msgstr ""
"برای دسترسی به پارامترهای ارسال شده در URL (``?key=value``) می توانید از ویژگی :"
"attr:`~flask.Request.args` استفاده کنید::"

#: ../../quickstart.rst:601
msgid ""
"We recommend accessing URL parameters with `get` or by catching the :exc:"
"`KeyError` because users might change the URL and presenting them a 400 bad "
"request page in that case is not user friendly."
msgstr ""
"توصیه می‌کنیم با `get` یا با :exc:`KeyError` به پارامترهای URL دسترسی پیدا کنید، "
"زیرا کاربر ممکن است URL را تغییر دهند و در این صورت یک صفحه درخواست 400 بد برای "
"آن‌ها ارائه می دهد که کاربر پسند نیست."

#: ../../quickstart.rst:605
msgid ""
"For a full list of methods and attributes of the request object, head over to "
"the :class:`~flask.Request` documentation."
msgstr ""
"برای فهرست کاملی از متدها و ویژگی های شی درخواست، مستندات :class:`~flask."
"Request` را بررسی کنید."

#: ../../quickstart.rst:610
msgid "File Uploads"
msgstr "آپلود فایل"

#: ../../quickstart.rst:612
msgid ""
"You can handle uploaded files with Flask easily.  Just make sure not to forget "
"to set the ``enctype=\"multipart/form-data\"`` attribute on your HTML form, "
"otherwise the browser will not transmit your files at all."
msgstr ""
"شما میتوانید به آسانی فایل هایتان را با فلاسک هندل کنید. فقط نباید فراموش کنید "
"که ``enctype=\"multipart/form-data\"`` را در فرم HTML خودتان قرار دهید مرورگر "
"شما بدون این فایلی را انتقال نخواهد داد."

#: ../../quickstart.rst:616
msgid ""
"Uploaded files are stored in memory or at a temporary location on the "
"filesystem.  You can access those files by looking at the :attr:`~flask.request."
"files` attribute on the request object.  Each uploaded file is stored in that "
"dictionary.  It behaves just like a standard Python :class:`file` object, but it "
"also has a :meth:`~werkzeug.datastructures.FileStorage.save` method that allows "
"you to store that file on the filesystem of the server. Here is a simple example "
"showing how that works::"
msgstr ""
"فایل های آپلود شده در حافظه یا یک مکان موقت در فایل سیستم ها ذخیره می‌شوند. شما "
"میتوانید با نگاه کردن به شی :attr:`~flask.request.files` دسترسی مناسب برای این "
"درخواست را بدهید. هر فایل آپلود شده در دایرکتوری ای ذخیره می‌شود. این مانند شی "
"استاندارد :class:`file` رفتار می‌کند ولی شیوه :meth:`~werkzeug.datastructures."
"FileStorage.save` همیشه مجاز می‌کند تا شما این فایل را در فایل سیستم ها ذخیره "
"کنید::"

#: ../../quickstart.rst:634
msgid ""
"If you want to know how the file was named on the client before it was uploaded "
"to your application, you can access the :attr:`~werkzeug.datastructures."
"FileStorage.filename` attribute. However please keep in mind that this value can "
"be forged so never ever trust that value.  If you want to use the filename of "
"the client to store the file on the server, pass it through the :func:`~werkzeug."
"utils.secure_filename` function that Werkzeug provides for you::"
msgstr ""
"اگر شما میخواهید بدانید که چگونه فایل ها قبل از آپلود در کلاینت برنامه شما نام "
"گزاری می‌شوند شیوه :attr:`~werkzeug.datastructures.FileStorage.filename`  را "
"بررسی کنید. با این حال لطفاً به خاطر داشته باشید که این شیوه قابل جعل است، "
"بنابراین هرگز به آن ارزش اعتماد نکنید. اگر می خواهید از نام فایل کلاینت برای "
"ذخیره فایل در سرور استفاده کنید، آن را از طریق تابع :func:`~werkzeug.utils."
"secure_filename` که Werkzeug برای شما ارائه می کند، ارسال کنید::"

#: ../../quickstart.rst:652
msgid "For some better examples, see :doc:`patterns/fileuploads`."
msgstr "برای مثال های بهتر :doc:`patterns/fileuploads` را ببینید."

#: ../../quickstart.rst:655
msgid "Cookies"
msgstr "کوکی ها(Cookies)"

#: ../../quickstart.rst:657
msgid ""
"To access cookies you can use the :attr:`~flask.Request.cookies` attribute.  To "
"set cookies you can use the :attr:`~flask.Response.set_cookie` method of "
"response objects.  The :attr:`~flask.Request.cookies` attribute of request "
"objects is a dictionary with all the cookies the client transmits.  If you want "
"to use sessions, do not use the cookies directly but instead use the :ref:"
"`sessions` in Flask that add some security on top of cookies for you."
msgstr ""
"برای دسترسی به کوکی ها می توانید از ویژگی :attr:`~flask.Request.cookies` استفاده "
"کنید. برای تنظیم کوکی ها می توانید از روش :attr:`~flask.Response.set_cookie` "
"برای اشیاء پاسخ استفاده کنید. ویژگی :attr:`~flask.Request.cookies` از اشیاء "
"درخواست، یک فرهنگ لغت با تمام کوکی هایی است که مشتری ارسال می کند. اگر می‌خواهید "
"از جلسات استفاده کنید، مستقیماً از کوکی‌ها استفاده نکنید، بلکه از :ref:`sessions` "
"در Flask استفاده کنید که امنیت را در بالای کوکی‌ها برای شما اضافه می‌کند."

#: ../../quickstart.rst:665
msgid "Reading cookies::"
msgstr "خواندن کوکی ها::"

#: ../../quickstart.rst:675
msgid "Storing cookies::"
msgstr "ذخیره کوکی ها::"

#: ../../quickstart.rst:685
msgid ""
"Note that cookies are set on response objects.  Since you normally just return "
"strings from the view functions Flask will convert them into response objects "
"for you.  If you explicitly want to do that you can use the :meth:`~flask."
"make_response` function and then modify it."
msgstr ""
"توجه داشته باشید که کوکی ها روی اشیاء پاسخ(response objects) تنظیم می شوند. از "
"آنجایی که شما معمولاً فقط رشته ها را از توابع view برمی گردانید، Flask آنها را به "
"اشیاء پاسخ برای شما تبدیل می کند. اگر صراحتاً می خواهید این کار را انجام دهید، می "
"توانید از تابع :meth:`~flask.make_response` استفاده کنید و سپس آن را تغییر دهید."

#: ../../quickstart.rst:690
msgid ""
"Sometimes you might want to set a cookie at a point where the response object "
"does not exist yet.  This is possible by utilizing the :doc:`patterns/"
"deferredcallbacks` pattern."
msgstr ""
"گاهی اوقات ممکن است بخواهید یک کوکی را در نقطه ای تنظیم کنید که شی پاسخ هنوز "
"وجود ندارد. این کار با استفاده از الگوی :doc:`patterns/deferredcallbacks`  امکان "
"پذیر است."

#: ../../quickstart.rst:694
msgid "For this also see :ref:`about-responses`."
msgstr "برای این نیز به :ref:`about-responses` مراجعه کنید."

#: ../../quickstart.rst:697
msgid "Redirects and Errors"
msgstr "تغییر مسیرها و خطاها(Redirects and Errors)"

#: ../../quickstart.rst:699
msgid ""
"To redirect a user to another endpoint, use the :func:`~flask.redirect` "
"function; to abort a request early with an error code, use the :func:`~flask."
"abort` function::"
msgstr ""
"برای تغییر مسیر کاربر به نقطه پایانی دیگر، از تابع :func:`~flask.redirect` "
"استفاده کنید. برای لغو زودهنگام درخواست با کد خطا، از تابع :func:`~flask.abort` "
"استفاده کنید::"

#: ../../quickstart.rst:714
msgid ""
"This is a rather pointless example because a user will be redirected from the "
"index to a page they cannot access (401 means access denied) but it shows how "
"that works."
msgstr ""
"این یک مثال نسبتاً بی‌معنی است زیرا کاربر از فهرست به صفحه‌ای هدایت می‌شود که "
"نمی‌تواند به آن دسترسی داشته باشد (۴۰۱ به معنای دسترسی ممنوع است) اما نشان می‌دهد "
"که چگونه کار می‌کند."

#: ../../quickstart.rst:718
msgid ""
"By default a black and white error page is shown for each error code.  If you "
"want to customize the error page, you can use the :meth:`~flask.Flask."
"errorhandler` decorator::"
msgstr ""
"به طور پیش فرض یک صفحه خطای سیاه و سفید برای هر کد خطا نشان داده می شود. اگر "
"می‌خواهید صفحه خطا را سفارشی کنید، می‌توانید از دکوراتور :meth:`~flask.Flask."
"errorhandler` استفاده کنید::"

#: ../../quickstart.rst:728
msgid ""
"Note the ``404`` after the :func:`~flask.render_template` call.  This tells "
"Flask that the status code of that page should be 404 which means not found.  By "
"default 200 is assumed which translates to: all went well."
msgstr ""
"بعد از فراخوانی :func:`~flask.render_template` به «۴۰۴» توجه کنید. این به فلاسک "
"می گوید که کد وضعیت آن صفحه باید ۴۰۴ باشد که به معنای یافت نشد. به طور پیش فرض "
"«۲۰۰» در نظر گرفته شده است که به این معنی است: همه چیز خوب پیش رفت."

#: ../../quickstart.rst:732
msgid "See :doc:`errorhandling` for more details."
msgstr "برای جزئیات بیشتر به :doc:`errorhandling` مراجعه کنید."

#: ../../quickstart.rst:737
msgid "About Responses"
msgstr "درباره پاسخ ها"

#: ../../quickstart.rst:739
msgid ""
"The return value from a view function is automatically converted into a response "
"object for you. If the return value is a string it's converted into a response "
"object with the string as response body, a ``200 OK`` status code and a :"
"mimetype:`text/html` mimetype. If the return value is a dict, :func:`jsonify` is "
"called to produce a response. The logic that Flask applies to converting return "
"values into response objects is as follows:"
msgstr ""
"مقدار بازگشتی از یک تابع view به طور خودکار به یک شی پاسخ برای شما تبدیل می شود. "
"اگر مقدار بازگشتی یک رشته باشد، به یک شی پاسخ با رشته به عنوان بدنه پاسخ، یک کد "
"وضعیت «۲۰۰ OK» و یک :mimetype:`text/html` تبدیل می شود. اگر مقدار بازگشتی یک "
"dict باشد، :func:`jsonify` برای ایجاد پاسخ فراخوانی می شود. منطقی که فلاسک برای "
"تبدیل مقادیر برگشتی به اشیاء پاسخ اعمال می کند به شرح زیر است:"

#: ../../quickstart.rst:747
msgid ""
"If a response object of the correct type is returned it's directly returned from "
"the view."
msgstr ""
"اگر یک شی پاسخ از نوع صحیح برگردانده شود، مستقیماً از نمای بازگردانده می شود."

#: ../../quickstart.rst:749
msgid ""
"If it's a string, a response object is created with that data and the default "
"parameters."
msgstr "اگر یک رشته باشد، یک شی پاسخ با آن داده و پارامترهای پیش فرض ایجاد می شود."

#: ../../quickstart.rst:751
msgid "If it's a dict, a response object is created using ``jsonify``."
msgstr "اگر یک دستور باشد، یک شی پاسخ با استفاده از ``jsonify`` ایجاد می شود."

#: ../../quickstart.rst:752
msgid ""
"If a tuple is returned the items in the tuple can provide extra information. "
"Such tuples have to be in the form ``(response, status)``, ``(response, "
"headers)``, or ``(response, status, headers)``. The ``status`` value will "
"override the status code and ``headers`` can be a list or dictionary of "
"additional header values."
msgstr ""
"اگر یک tuple برگردانده شود، آیتم های تاپل می توانند اطلاعات بیشتری را ارائه "
"دهند. این تاپل ها باید به شکل ``(response, status)``،``(response, headers)`` یا "
"``(response, status, headers)`` باشند. مقدار ``status`` کد وضعیت را لغو می کند و "
"``headers`` می تواند فهرست یا فرهنگ لغت مقادیر اضافی سرصفحه باشد."

#: ../../quickstart.rst:758
msgid ""
"If none of that works, Flask will assume the return value is a valid WSGI "
"application and convert that into a response object."
msgstr ""
"اگر هیچ کدام از این موارد کار نکرد، فلاسک مقدار بازگشتی را یک برنامه معتبر WSGI "
"فرض می‌کند و آن را به یک شی پاسخ تبدیل می‌کند."

#: ../../quickstart.rst:761
msgid ""
"If you want to get hold of the resulting response object inside the view you can "
"use the :func:`~flask.make_response` function."
msgstr ""
"اگر می خواهید شی پاسخ به دست آمده را در داخل view نگه دارید، می توانید از تابع :"
"func:`~flask.make_response` استفاده کنید."

#: ../../quickstart.rst:764
msgid "Imagine you have a view like this::"
msgstr "تصور کنید نماای مثل این دارید::"

#: ../../quickstart.rst:772
msgid ""
"You just need to wrap the return expression with :func:`~flask.make_response` "
"and get the response object to modify it, then return it::"
msgstr ""
"شما فقط باید عبارت return را با :func:`~flask.make_response` بگزارید و شی پاسخ "
"را دریافت کنید تا آن را تغییر دهید، سپس آن را برگردانید::"

#: ../../quickstart.rst:786
msgid "APIs with JSON"
msgstr "ای پی آی با جیسان(APIs with JSON)"

#: ../../quickstart.rst:788
msgid ""
"A common response format when writing an API is JSON. It's easy to get started "
"writing such an API with Flask. If you return a ``dict`` from a view, it will be "
"converted to a JSON response."
msgstr ""
"فرمت پاسخ متداول هنگام نوشتن یک API، جیسان(JSON) است. شروع نوشتن چنین جیسان با "
"فلاسک آسان است. اگر یک ``dict``  را از یک نمای برگردانید، به یک پاسخ JSON تبدیل "
"می‌شود."

#: ../../quickstart.rst:803
msgid ""
"Depending on your API design, you may want to create JSON responses for types "
"other than ``dict``. In that case, use the :func:`~flask.json.jsonify` function, "
"which will serialize any supported JSON data type. Or look into Flask community "
"extensions that support more complex applications."
msgstr ""
"بسته به طراحی API خود، ممکن است بخواهید پاسخ‌های JSON را برای انواعی غیر از "
"``dict`` ایجاد کنید. در آن صورت، از تابع :func:`~flask.json.jsonify`  استفاده "
"کنید، که هر نوع داده JSON پشتیبانی شده را سریال می کند. یا به برنامه های افزودنی "
"انجمن فلاسک که از برنامه های پیچیده تری پشتیبانی می کنند نگاه کنید."

#: ../../quickstart.rst:822
msgid "Sessions"
msgstr "جلسات(Sessions)"

#: ../../quickstart.rst:824
msgid ""
"In addition to the request object there is also a second object called :class:"
"`~flask.session` which allows you to store information specific to a user from "
"one request to the next.  This is implemented on top of cookies for you and "
"signs the cookies cryptographically.  What this means is that the user could "
"look at the contents of your cookie but not modify it, unless they know the "
"secret key used for signing."
msgstr ""
"علاوه بر شی درخواست، شی دومی به نام :class:`~flask.session` نیز وجود دارد که به "
"شما امکان می دهد اطلاعات خاص یک کاربر را از یک درخواست به درخواست دیگر ذخیره "
"کنید. این در بالای کوکی ها برای شما اجرا می شود و کوکی ها را به صورت رمزنگاری "
"امضا می کند. این بدان معناست که کاربر می تواند به محتویات کوکی شما نگاه کند اما "
"آن را تغییر ندهد، مگر اینکه کلید مخفی مورد استفاده برای امضا را بداند."

#: ../../quickstart.rst:831
msgid ""
"In order to use sessions you have to set a secret key.  Here is how sessions "
"work::"
msgstr ""
"برای استفاده از جلسات باید یک کلید مخفی تنظیم کنید. نحوه کار جلسات به شرح زیر "
"است:"

#: ../../quickstart.rst:863
msgid "How to generate good secret keys"
msgstr "چگونه کلید مخفی خوبی بسازیم"

#: ../../quickstart.rst:865
msgid ""
"A secret key should be as random as possible. Your operating system has ways to "
"generate pretty random data based on a cryptographic random generator. Use the "
"following command to quickly generate a value for :attr:`Flask.secret_key` (or :"
"data:`SECRET_KEY`)::"
msgstr ""
"یک کلید مخفی باید تا حد امکان تصادفی باشد. سیستم عامل شما راه هایی برای تولید "
"داده های بسیار تصادفی بر اساس یک ژنراتور تصادفی رمزنگاری دارد. از دستور زیر برای "
"ایجاد سریع مقدار برای :attr:`Flask.secret_key` (یا :data:`SECRET_KEY`)::"

#: ../../quickstart.rst:873
msgid ""
"A note on cookie-based sessions: Flask will take the values you put into the "
"session object and serialize them into a cookie.  If you are finding some values "
"do not persist across requests, cookies are indeed enabled, and you are not "
"getting a clear error message, check the size of the cookie in your page "
"responses compared to the size supported by web browsers."
msgstr ""
"نکته ای در مورد جلسات مبتنی بر کوکی: فلاسک مقادیری را که در شی جلسه قرار داده "
"اید می گیرد و آنها را به صورت سریالی در یک کوکی قرار می دهد. اگر متوجه شدید که "
"برخی از مقادیر در بین درخواست‌ها باقی نمی‌مانند، کوکی‌ها در واقع فعال هستند و پیام "
"خطای واضحی دریافت نمی‌کنید، اندازه کوکی را در پاسخ‌های صفحه خود در مقایسه با "
"اندازه پشتیبانی شده توسط مرورگرهای وب بررسی کنید."

#: ../../quickstart.rst:879
msgid ""
"Besides the default client-side based sessions, if you want to handle sessions "
"on the server-side instead, there are several Flask extensions that support this."
msgstr ""
"علاوه بر جلسات پیش‌فرض مبتنی بر کلاینت، اگر می‌خواهید جلسات را در سمت سرور مدیریت "
"کنید، چندین افزونه فلاسک وجود دارد که از این امر پشتیبانی می‌کنند."

#: ../../quickstart.rst:884
msgid "Message Flashing"
msgstr "فلش کردن پیام(Message Flashing)"

#: ../../quickstart.rst:886
msgid ""
"Good applications and user interfaces are all about feedback.  If the user does "
"not get enough feedback they will probably end up hating the application.  Flask "
"provides a really simple way to give feedback to a user with the flashing "
"system.  The flashing system basically makes it possible to record a message at "
"the end of a request and access it on the next (and only the next) request.  "
"This is usually combined with a layout template to expose the message."
msgstr ""
"برنامه ها و رابط های کاربری خوب همه در مورد بازخورد هستند. اگر کاربر بازخورد "
"کافی دریافت نکند، احتمالاً از برنامه متنفر خواهد شد. فلاسک یک راه بسیار ساده برای "
"ارائه بازخورد به کاربر با سیستم فلش ارائه می دهد. سیستم فلش اساساً امکان ضبط یک "
"پیام در انتهای درخواست و دسترسی به آن در درخواست بعدی (و فقط درخواست بعدی) را "
"فراهم می کند. این معمولاً با یک الگوی طرح بندی ترکیب می شود تا پیام را آشکار کند."

#: ../../quickstart.rst:894
msgid ""
"To flash a message use the :func:`~flask.flash` method, to get hold of the "
"messages you can use :func:`~flask.get_flashed_messages` which is also available "
"in the templates. See :doc:`patterns/flashing` for a full example."
msgstr ""
"برای فلش کردن یک پیام از روش :func:`~flask.flash` استفاده کنید، برای دریافت پیام "
"ها می توانید از :func:`~flask.get_flashed_messages` استفاده کنید که در قالب ها "
"نیز موجود است. برای مثال کامل به :doc:`patterns/flashing` مراجعه کنید."

#: ../../quickstart.rst:900
msgid "Logging"
msgstr "لاگ کردن(Logging)"

#: ../../quickstart.rst:904
msgid ""
"Sometimes you might be in a situation where you deal with data that should be "
"correct, but actually is not.  For example you may have some client-side code "
"that sends an HTTP request to the server but it's obviously malformed.  This "
"might be caused by a user tampering with the data, or the client code failing.  "
"Most of the time it's okay to reply with ``400 Bad Request`` in that situation, "
"but sometimes that won't do and the code has to continue working."
msgstr ""
"گاهی اوقات ممکن است در موقعیتی قرار بگیرید که با داده هایی برخورد می کنید که "
"باید درست باشند، اما در واقع اینطور نیست. به عنوان مثال، ممکن است تعدادی کد سمت "
"کلاینت داشته باشید که یک درخواست HTTP را به سرور ارسال می کند، اما به وضوح بدشکل "
"است. این ممکن است به دلیل دستکاری کاربر در داده ها یا خرابی کد مشتری باشد. در "
"بیشتر مواقع پاسخ دادن با ``400 Bad Request`` در آن موقعیت اشکالی ندارد، اما گاهی "
"اوقات این کار انجام نمی‌شود و کد باید به کار خود ادامه دهد."

#: ../../quickstart.rst:912
msgid ""
"You may still want to log that something fishy happened.  This is where loggers "
"come in handy.  As of Flask 0.3 a logger is preconfigured for you to use."
msgstr ""
"ممکن است هنوز بخواهید ثبت کنید که یک اتفاق عجیب رخ داده است. اینجاست که لاگرها "
"به کار می آیند. از Flask 0.3 یک لاگر از قبل برای استفاده شما پیکربندی شده است."

#: ../../quickstart.rst:916
msgid "Here are some example log calls::"
msgstr "در اینجا چند نمونه از لاگ ها آورده شده است:"

#: ../../quickstart.rst:922
msgid ""
"The attached :attr:`~flask.Flask.logger` is a standard logging :class:`~logging."
"Logger`, so head over to the official :mod:`logging` docs for more information."
msgstr ""
":attr:`~flask.Flask.logger` پیوست شده یک گزارش استاندارد :class:`~logging."
"Logger` است، بنابراین برای اطلاعات بیشتر به اسناد رسمی :mod:`logging` بروید."

#: ../../quickstart.rst:926
msgid "See :doc:`errorhandling`."
msgstr "به :doc:`errorhandling` مراجعه کنید."

#: ../../quickstart.rst:930
msgid "Hooking in WSGI Middleware"
msgstr "قلاب کردن در WSGI Middleware"

#: ../../quickstart.rst:932
msgid ""
"To add WSGI middleware to your Flask application, wrap the application's "
"``wsgi_app`` attribute. For example, to apply Werkzeug's :class:`~werkzeug."
"middleware.proxy_fix.ProxyFix` middleware for running behind Nginx:"
msgstr ""
"برای افزودن میان‌افزار WSGI به برنامه Flask خود، ویژگی ``wsgi_app`` برنامه را "
"بپیچید. برای مثال، برای اعمال میان‌افزار  :class:`~werkzeug.middleware.proxy_fix."
"ProxyFix` برای اجرای پشت Nginx کد زیر را ببنید:"

#: ../../quickstart.rst:942
msgid ""
"Wrapping ``app.wsgi_app`` instead of ``app`` means that ``app`` still points at "
"your Flask application, not at the middleware, so you can continue to use and "
"configure ``app`` directly."
msgstr ""
"قرار دادن ``app.wsgi_app`` به جای ``app`` به این معنی است که ``app`` همچنان به "
"برنامه فلاسک شما اشاره می‌کند، نه به میان‌افزار، بنابراین می‌توانید مستقیماً به "
"استفاده و پیکربندی ``app`` ادامه دهید."

#: ../../quickstart.rst:947
msgid "Using Flask Extensions"
msgstr "استفاده از افزونه های فلاسک"

#: ../../quickstart.rst:949
msgid ""
"Extensions are packages that help you accomplish common tasks. For example, "
"Flask-SQLAlchemy provides SQLAlchemy support that makes it simple and easy to "
"use with Flask."
msgstr ""
"افزونه ها پکیج هایی هستند که کمک میکنند تا تکالیف مشترکی را انجام دهند. برای "
"مثال Flask-SQLAlchemy پشتیبانی از  SQLAlchemy راه تهیه میکند و کار با آن در "
"فلاسک را آسانتر میسازد."

#: ../../quickstart.rst:953
msgid "For more on Flask extensions, see :doc:`extensions`."
msgstr "برای افزونه های بیشتر فلاسک :doc:`extensions` را ببنید."

#: ../../quickstart.rst:956
msgid "Deploying to a Web Server"
msgstr "استقرار کردن به یک وب سرور"

#: ../../quickstart.rst:958
msgid "Ready to deploy your new Flask app? See :doc:`deploying/index`."
msgstr ""
"آیا برای استقرار برنامه فلاسک جدیدتان آماده اید؟  :doc:`deploying/index` با "
"ببنید."

#~ msgid "The interactive debugger in action."
#~ msgstr "اشکال زدای تعاملی در عمل"
