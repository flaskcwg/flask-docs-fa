# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets
# This file is distributed under the same license as the Flask package.
# Mohamad Balkhi  <ahmdparsh129@gmail.com>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: Flask 2.1.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-12-11 23:45+0330\n"
"PO-Revision-Date: 2021-12-12 20:26+0330\n"
"Last-Translator: Mohamad Balkhi  <ahmdparsh129@gmail.com>\n"
"Language: fa\n"
"Language-Team: fa <ahmdparsh129@gmail.com>\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../quickstart.rst:2
msgid "Quickstart"
msgstr "شروع سریع"

#: ../../quickstart.rst:4
msgid ""
"Eager to get started? This page gives a good introduction to Flask. "
"Follow :doc:`installation` to set up a project and install Flask first."
msgstr ""
"برای شروع مشتاق هستید؟ این صفحه معرفی خوبی برای فلاسک میدهد. برای "
"راه‌اندازی یک پروژه و نصب فلاسک ابتدا :doc:`installation` را دنبال کنید."

#: ../../quickstart.rst:9
msgid "A Minimal Application"
msgstr "یک برنامه مینیمال"

#: ../../quickstart.rst:11
msgid "A minimal Flask application looks something like this:"
msgstr "یک اپلیکیشن فلاسک مینیمال چیزی شبیه به این است:"

#: ../../quickstart.rst:23
msgid "So what did that code do?"
msgstr "پس آن کد چه کرد؟"

#: ../../quickstart.rst:25
msgid ""
"First we imported the :class:`~flask.Flask` class. An instance of this "
"class will be our WSGI application."
msgstr ""
"ابتدا کلاس :class:`~flask.Flask` را وارد کردیم. یک نمونه کلاس در برنامه "
"WSGI ما اینگونه خواهد بود."

#: ../../quickstart.rst:27
msgid ""
"Next we create an instance of this class. The first argument is the name "
"of the application's module or package. ``__name__`` is a convenient "
"shortcut for this that is appropriate for most cases. This is needed so "
"that Flask knows where to look for resources such as templates and static"
" files."
msgstr ""
"بعد، یک نمونه از این کلاس ایجاد می کنیم. اولین آرگومان نام ماژول یا بسته "
"برنامه است. ``__name__`` میانبر مناسبی برای این کار است که برای اکثر "
"موارد مناسب است. این مورد نیاز است تا فلاسک بداند در کجا به دنبال منابعی "
"مانند قالب ها و فایل های استاتیک باشد."

#: ../../quickstart.rst:32
msgid ""
"We then use the :meth:`~flask.Flask.route` decorator to tell Flask what "
"URL should trigger our function."
msgstr ""
"سپس از دکوراتور :meth:`~flask.Flask.route` استفاده می کنیم تا به فلاسک "
"بگوییم چه URLی باید عملکرد ما را راه اندازی کند."

#: ../../quickstart.rst:34
msgid ""
"The function returns the message we want to display in the user's "
"browser. The default content type is HTML, so HTML in the string will be "
"rendered by the browser."
msgstr ""
"تابع پیامی را که می خواهیم در مرورگر کاربر نمایش دهیم برمی گرداند. نوع "
"محتوای پیش فرض HTML است، بنابراین HTML در رشته توسط مرورگر ارائه می شود."

#: ../../quickstart.rst:38
msgid ""
"Save it as :file:`hello.py` or something similar. Make sure to not call "
"your application :file:`flask.py` because this would conflict with Flask "
"itself."
msgstr ""
"آن را به صورت :file:`hello.py` یا چیزی مشابه ذخیره کنید. مطمئن شوید که "
"برنامه خود را :file:`flask.py` فرا نخوانید زیرا با خود فلاسک در تضاد است."

#: ../../quickstart.rst:42
msgid ""
"To run the application, use the :command:`flask` command or "
":command:`python -m flask`. Before you can do that you need to tell your "
"terminal the application to work with by exporting the ``FLASK_APP`` "
"environment variable:"
msgstr ""
"برای اجرای برنامه، از دستور :command:`flask` یا :command:`python -m "
"flask` استفاده کنید. قبل از اینکه بتوانید این کار را انجام دهید، باید به "
"ترمینال خود بگویید که برنامه با صادر کردن متغیر محیطی ``FLASK_APP`` با آن"
" کار کند:"

#: ../../quickstart.rst:49 ../../quickstart.rst:162
msgid "Bash"
msgstr "Bash"

#: ../../quickstart.rst:57 ../../quickstart.rst:169
msgid "CMD"
msgstr "CMD"

#: ../../quickstart.rst:65 ../../quickstart.rst:176
msgid "Powershell"
msgstr "Powershell"

#: ../../quickstart.rst:73
msgid "Application Discovery Behavior"
msgstr "رفتار کشف برنامه"

#: ../../quickstart.rst:75
msgid ""
"As a shortcut, if the file is named ``app.py`` or ``wsgi.py``, you don't "
"have to set the ``FLASK_APP`` environment variable. See :doc:`/cli` for "
"more details."
msgstr ""
"به عنوان میانبر، اگر نام فایل ``app.py`` یا ``wsgi.py`` باشد، لازم نیست "
"متغیر محیطی ``FLASK_APP`` را تنظیم کنید. برای جزئیات بیشتر به :doc:`/cli`"
" مراجعه کنید."

#: ../../quickstart.rst:79
msgid ""
"This launches a very simple builtin server, which is good enough for "
"testing but probably not what you want to use in production. For "
"deployment options see :doc:`deploying/index`."
msgstr ""
"این یک سرور داخلی بسیار ساده را راه اندازی می کند که برای آزمایش به "
"اندازه کافی خوب است اما احتمالاً آن چیزی نیست که می خواهید در تولید "
"استفاده کنید. برای گزینه های استقرار به :doc:`deploying/index` مراجعه "
"کنید."

#: ../../quickstart.rst:83
msgid ""
"Now head over to http://127.0.0.1:5000/, and you should see your hello "
"world greeting."
msgstr "اکنون به http://127.0.0.1:5000/ بروید، و باید سلام جهان را ببینید."

#: ../../quickstart.rst:86
msgid ""
"If another program is already using port 5000, you'll see ``OSError: "
"[Errno 98]`` or ``OSError: [WinError 10013]`` when the server tries to "
"start. See :ref:`address-already-in-use` for how to handle that."
msgstr ""
"اگر برنامه دیگری در حال حاضر از پورت 5000 استفاده می کند، زمانی که سرور "
"تلاش می کند راه اندازی شود، ``OSError: [WinError 10013]`` یا ``OSError: "
"[Errno 98]`` را مشاهده خواهید کرد. برای نحوه رسیدگی به آن به :ref"
":`address-already-in-use` مراجعه کنید."

#: ../../quickstart.rst:93
msgid "Externally Visible Server"
msgstr "سرور قابل مشاهده خارجی"

#: ../../quickstart.rst:95
msgid ""
"If you run the server you will notice that the server is only accessible "
"from your own computer, not from any other in the network.  This is the "
"default because in debugging mode a user of the application can execute "
"arbitrary Python code on your computer."
msgstr ""
"اگر سرور را اجرا کنید، متوجه خواهید شد که سرور فقط از طریق رایانه شخصی "
"شما قابل دسترسی است، نه از هیچ رایانه دیگری در شبکه. این پیش‌فرض است زیرا"
" در حالت اشکال‌زدایی، کاربر برنامه می‌تواند کد پایتون دلخواه را روی "
"رایانه شما اجرا کند."

#: ../../quickstart.rst:100
msgid ""
"If you have the debugger disabled or trust the users on your network, you"
" can make the server publicly available simply by adding "
"``--host=0.0.0.0`` to the command line::"
msgstr ""
"اگر دیباگر را غیرفعال کرده اید یا به کاربران شبکه خود اعتماد دارید، می "
"توانید سرور را به سادگی با افزودن``--host=0.0.0.0`` به خط فرمان در دسترس "
"عموم قرار دهید:"

#: ../../quickstart.rst:106
msgid "This tells your operating system to listen on all public IPs."
msgstr "این به سیستم عامل شما می گوید که به تمام IP های عمومی گوش دهد."

#: ../../quickstart.rst:110
msgid "What to do if the Server does not Start"
msgstr "اگر سرور راه اندازی نشد چه باید کرد"

#: ../../quickstart.rst:112
msgid ""
"In case the :command:`python -m flask` fails or :command:`flask` does not"
" exist, there are multiple reasons this might be the case. First of all "
"you need to look at the error message."
msgstr ""
"در صورتی که :command:`python -m flask` از کار بیفتد یا :command:`flask` "
"وجود نداشته باشد، دلایل متعددی ممکن است وجود داشته باشد. اول از همه باید "
"به پیام خطا نگاه کنید."

#: ../../quickstart.rst:117
msgid "Old Version of Flask"
msgstr "نسخه قدیمی فلاسک"

#: ../../quickstart.rst:119
msgid ""
"Versions of Flask older than 0.11 used to have different ways to start "
"the application.  In short, the :command:`flask` command did not exist, "
"and neither did :command:`python -m flask`.  In that case you have two "
"options: either upgrade to newer Flask versions or have a look at "
":doc:`/server` to see the alternative method for running a server."
msgstr ""
"در نسخه های ۰.۱۱ و قبل از آن تفاوتی در اجرای برنامه بود. به صورت کوتاه، "
":command:`flask` و :command:`python -m flask` وجود خارجی نداشتند. در این "
"حالت شما دو انتخاب داشتید: یا فلاسک را به نسخه های جدیدتر بروز کنید یا "
":doc:`/server` را بررسی میکردید تا روشی تناوبی برای اجرای سرور بیابید."

#: ../../quickstart.rst:126
msgid "Invalid Import Name"
msgstr "وارد کردن اسم نامعتبر"

#: ../../quickstart.rst:128
msgid ""
"The ``FLASK_APP`` environment variable is the name of the module to "
"import at :command:`flask run`. In case that module is incorrectly named "
"you will get an import error upon start (or if debug is enabled when you "
"navigate to the application). It will tell you what it tried to import "
"and why it failed."
msgstr ""
"متغیر محیطی``FLASK_APP`` نام ماژولی است که باید در :command:`flask run` "
"وارد شود. در صورتی که نام آن ماژول اشتباه باشد، هنگام شروع با خطای وارد "
"کردن مواجه خواهید شد (یا اگر هنگام رفتن به برنامه، اشکال زدایی فعال "
"باشد). به شما می گوید که چه چیزی را وارد کرده و چرا شکست خورده است."

#: ../../quickstart.rst:133
msgid ""
"The most common reason is a typo or because you did not actually create "
"an ``app`` object."
msgstr ""
"رایج‌ترین دلیل اشتباه تایپی است یا اینکه شما واقعاً یک شی ``app`` ایجاد "
"نکرده‌اید."

#: ../../quickstart.rst:138
msgid "Debug Mode"
msgstr "حالت اشکال زدایی"

#: ../../quickstart.rst:140
msgid ""
"The ``flask run`` command can do more than just start the development "
"server. By enabling debug mode, the server will automatically reload if "
"code changes, and will show an interactive debugger in the browser if an "
"error occurs during a request."
msgstr ""
"دستور ``flask run`` میتواند کار های بیشتری از توسعه سرور انجام دهد. با "
"فعال سازی حالت اشکال زدایی سرور درصورت تغییر کد به صورت خودکار باز "
"راه‌اندازی میشود و در صورت بروز خطا در هنگام درخواست، یک دیباگر تعاملی را"
" در مرورگر نشان می دهد."

msgid "اشکال زدای تعاملی در عمل."
msgstr ""

#: ../../quickstart.rst:152
msgid ""
"The debugger allows executing arbitrary Python code from the browser. It "
"is protected by a pin, but still represents a major security risk. Do not"
" run the development server or debugger in a production environment."
msgstr ""
"دیباگر اجازه می دهد تا کد پایتون دلخواه را از مرورگر اجرا کنید. توسط یک "
"پین محافظت می شود، اما همچنان یک خطر امنیتی بزرگ است. سرور توسعه یا "
"دیباگر را در محیط تولید اجرا نکنید."

#: ../../quickstart.rst:157
msgid ""
"To enable all development features, set the ``FLASK_ENV`` environment "
"variable to ``development`` before calling ``flask run``."
msgstr ""
"برای فعال سازی تمام قابلیت های توسعه، قبل از اجرای ``flask run`` ، متغیر "
"محیطی ``FLASK_ENV`` را برابر ``development`` قرار دهید."

#: ../../quickstart.rst:183
msgid "See also:"
msgstr "همچنین ببینید:"

#: ../../quickstart.rst:185
msgid ""
":doc:`/server` and :doc:`/cli` for information about running in "
"development mode."
msgstr ""
"برای اطلاعات درباره اجرا در حالت توسعه :doc:`/server` و :doc:`/cli` را "
"ببینید."

#: ../../quickstart.rst:187
msgid ""
":doc:`/debugging` for information about using the built-in debugger and "
"other debuggers."
msgstr ""
"برای اطلاعات درباره دیباگر داخلی و سایر دیباگر ها :doc:`/debugging` "
"ببینید."

#: ../../quickstart.rst:189
msgid ""
":doc:`/logging` and :doc:`/errorhandling` to log errors and display nice "
"error pages."
msgstr ""
":doc:`/logging` و :doc:`/errorhandling` را برای لاگ های ارور و نمایش بهتر"
" صفحات ارور ببینید."

#: ../../quickstart.rst:194
msgid "HTML Escaping"
msgstr "HTML Escaping"

# مقاوم:escape
#: ../../quickstart.rst:196
msgid ""
"When returning HTML (the default response type in Flask), any user-"
"provided values rendered in the output must be escaped to protect from "
"injection attacks. HTML templates rendered with Jinja, introduced later, "
"will do this automatically."
msgstr ""
"هنگام برگرداندن HTML (نوع پاسخ پیش‌فرض در فلاسک)، هر مقدار ارائه‌شده توسط"
" کاربر که در خروجی ارائه می‌شود، باید برای محافظت در برابر حملات XSS "
"مقاوم باشند. قالب‌های HTML ارائه‌شده با Jinja، که بعداً معرفی شدند، این "
"کار را به‌طور خودکار انجام می‌دهند."

#: ../../quickstart.rst:201
msgid ""
":func:`~markupsafe.escape`, shown here, can be used manually. It is "
"omitted in most examples for brevity, but you should always be aware of "
"how you're using untrusted data."
msgstr ""
"تابع :func:`~markupsafe.escape`، که در اینجا نشان داده شده است، می تواند "
"به صورت دستی استفاده شود. در بیشتر نمونه ها برای اختصار از آن حذف شده "
"است، اما همیشه باید از نحوه استفاده از داده های نامعتبر آگاه باشید."

# escape:فرار
#: ../../quickstart.rst:213
msgid ""
"If a user managed to submit the name ``<script>alert(\"bad\")</script>``,"
" escaping causes it to be rendered as text, rather than running the "
"script in the user's browser."
msgstr ""
"اگر کاربر موفق به ارسال ``<script>alert(\"bad\")</script>`` شود، فرار "
"باعث می شود که به جای اجرای اسکریپت در مرورگر کاربر، به صورت متن ارائه "
"شود."

#: ../../quickstart.rst:217
msgid ""
"``<name>`` in the route captures a value from the URL and passes it to "
"the view function. These variable rules are explained below."
msgstr ""
"``<name>`` در مسیر یک مقدار از URL گرفته و به تابع view ارسال می کند. این"
" قوانین متغیر در زیر توضیح داده شده است."

#: ../../quickstart.rst:222
msgid "Routing"
msgstr "مسیریابی"

#: ../../quickstart.rst:224
msgid ""
"Modern web applications use meaningful URLs to help users. Users are more"
" likely to like a page and come back if the page uses a meaningful URL "
"they can remember and use to directly visit a page."
msgstr ""
"برنامه های وب مدرن از URL های معنی دار برای کمک به کاربران استفاده می "
"کنند. اگر کاربران یک صفحه را دوست داشته باشند و اگر صفحه از URL معنی‌داری"
" استفاده کند، کاربران می‌توانند URL را به خاطر بسپارند و مستقیماً از صفحه"
" بازدید کنند."

#: ../../quickstart.rst:228
msgid ""
"Use the :meth:`~flask.Flask.route` decorator to bind a function to a URL."
" ::"
msgstr ""
"از دکوراتور :meth:`~flask.Flask.route` برای اتصال یک تابع به URL استفاده "
"کنید. ::"

#: ../../quickstart.rst:238
msgid ""
"You can do more! You can make parts of the URL dynamic and attach "
"multiple rules to a function."
msgstr ""
"شما میتوانید کار های زیادی را انجام دهید! میتوانید بخشی از URL را پویا "
"کنید و چند قانون به تابع اضافه کنید."

#: ../../quickstart.rst:242
msgid "Variable Rules"
msgstr "قوانین متغیر"

#: ../../quickstart.rst:244
msgid ""
"You can add variable sections to a URL by marking sections with "
"``<variable_name>``. Your function then receives the ``<variable_name>`` "
"as a keyword argument. Optionally, you can use a converter to specify the"
" type of the argument like ``<converter:variable_name>``. ::"
msgstr ""
"می‌توانید با علامت‌گذاری بخش‌ها با ``<variable_name>`` ، بخش‌هایی از "
"متغیر را به URL اضافه کنید. سپس تابع شما ``<variable_name>`` را به عنوان "
"آرگومان کلمه کلیدی دریافت می کند. به صورت اختیاری، می توانید از یک مبدل "
"برای تعیین نوع آرگومان مانند ``<converter:variable_name>`` استفاده کنید. "
"::"

#: ../../quickstart.rst:266
msgid "Converter types:"
msgstr "انواع مبدل:"

#: ../../quickstart.rst:269
msgid "``string``"
msgstr "``رشته``"

#: ../../quickstart.rst:269
msgid "(default) accepts any text without a slash"
msgstr "به صورت پیشفرض هر متنی را بدون اسلش می پذیرد"

#: ../../quickstart.rst:270
msgid "``int``"
msgstr "``عدد صحیح``"

#: ../../quickstart.rst:270
msgid "accepts positive integers"
msgstr "اعداد صحیح مثبت را می پذیرد"

#: ../../quickstart.rst:271
msgid "``float``"
msgstr "``عدد اعشاری``"

#: ../../quickstart.rst:271
msgid "accepts positive floating point values"
msgstr "تمام اعداد اعشاری مثبت را می پذیرد"

#: ../../quickstart.rst:272
msgid "``path``"
msgstr "``مسیر``"

#: ../../quickstart.rst:272
msgid "like ``string`` but also accepts slashes"
msgstr "مانند ``رشته`` است ولی اسلش را هم می پذیرد"

#: ../../quickstart.rst:273
msgid "``uuid``"
msgstr "``uuid``"

#: ../../quickstart.rst:273
msgid "accepts UUID strings"
msgstr "رشته های UUID را می پذیرد"

#: ../../quickstart.rst:278
msgid "Unique URLs / Redirection Behavior"
msgstr "URL های منحصر به فرد / رفتار تغییر مسیر"

#: ../../quickstart.rst:280
msgid "The following two rules differ in their use of a trailing slash. ::"
msgstr "دو قانون زیر در استفاده از اسلش انتهایی متفاوت است. ::"

#: ../../quickstart.rst:290
msgid ""
"The canonical URL for the ``projects`` endpoint has a trailing slash. "
"It's similar to a folder in a file system. If you access the URL without "
"a trailing slash (``/projects``), Flask redirects you to the canonical "
"URL with the trailing slash (``/projects/``)."
msgstr ""
"URL متعارف برای نقطه پایانی ``projects`` دارای یک اسلش انتهایی است. این "
"شبیه به یک پوشه در یک سیستم فایل است. اگر بدون اسلش انتهایی "
"(``/projects``) به URL دسترسی داشته باشید، Flask شما را به URL متعارف با "
"اسلش انتهایی (``/projects/``) هدایت می کند."

#: ../../quickstart.rst:295
msgid ""
"The canonical URL for the ``about`` endpoint does not have a trailing "
"slash. It's similar to the pathname of a file. Accessing the URL with a "
"trailing slash (``/about/``) produces a 404 \"Not Found\" error. This "
"helps keep URLs unique for these resources, which helps search engines "
"avoid indexing the same page twice."
msgstr ""
"URL متعارف برای نقطه پایانی ``about`` دارای یک اسلش انتهایی نیست. این "
"شبیه به نام مسیر یک فایل است. دسترسی به URL با اسلش انتهایی (``/about/``)"
" باعث ایجاد خطای 404 \"Not Found\" می شود. این کمک می کند تا URL ها برای "
"این منابع منحصر به فرد باقی بمانند، که به موتورهای جستجو کمک می کند تا از"
" نمایه سازی یک صفحه دو بار جلوگیری کنند."

#: ../../quickstart.rst:305
msgid "URL Building"
msgstr "ساخت URL"

#: ../../quickstart.rst:307
msgid ""
"To build a URL to a specific function, use the :func:`~flask.url_for` "
"function. It accepts the name of the function as its first argument and "
"any number of keyword arguments, each corresponding to a variable part of"
" the URL rule. Unknown variable parts are appended to the URL as query "
"parameters."
msgstr ""
"برای ساخت یک URL برای یک تابع خاص، از تابع :func:`~flask.url_for` استفاده"
" کنید. نام تابع را به عنوان اولین آرگومان و هر تعداد آرگومان کلمه کلیدی "
"که هر کدام مربوط به بخش متغیری از قانون URL است را می پذیرد. قسمت های "
"متغیر ناشناخته به عنوان پارامترهای پرس و جو به URL اضافه می شوند."

#: ../../quickstart.rst:312
msgid ""
"Why would you want to build URLs using the URL reversing function "
":func:`~flask.url_for` instead of hard-coding them into your templates?"
msgstr ""
"چرا می خواهید URL ها را با استفاده از تابع :func:`~flask.url_for` بسازید "
"به جای آنکه کد ها را در قالب های خود بنویسید؟"

#: ../../quickstart.rst:315
msgid "Reversing is often more descriptive than hard-coding the URLs."
msgstr "معکوس کردن اغلب توصیفی از کدگذاری سخت URL ها است."

#: ../../quickstart.rst:316
msgid ""
"You can change your URLs in one go instead of needing to remember to "
"manually change hard-coded URLs."
msgstr ""
"می‌توانید به‌جای اینکه به یاد داشته باشید که URL‌های کدگذاری‌شده را "
"به‌صورت دستی تغییر دهید، آدرس‌های اینترنتی خود را یکباره تغییر دهید."

#: ../../quickstart.rst:318
msgid "URL building handles escaping of special characters transparently."
msgstr "ساختمان فرار URL از کاراکترهای خاص را به طور شفاف کنترل می کند."

#: ../../quickstart.rst:319
msgid ""
"The generated paths are always absolute, avoiding unexpected behavior of "
"relative paths in browsers."
msgstr ""
"مسیرهای تولید شده همیشه مطلق هستند و از رفتار غیرمنتظره مسیرهای وابسته در"
" مرورگرها جلوگیری می کنند."

#: ../../quickstart.rst:321
msgid ""
"If your application is placed outside the URL root, for example, in "
"``/myapplication`` instead of ``/``, :func:`~flask.url_for` properly "
"handles that for you."
msgstr ""
"اگر برنامه شما خارج از ریشه URL قرار داده شده است، به عنوان مثال، به جای "
"``/`` در ``/myapplication`` باشد، :func:`~flask.url_for` به درستی آن را "
"برای شما مدیریت می کند."

#: ../../quickstart.rst:325
msgid ""
"For example, here we use the :meth:`~flask.Flask.test_request_context` "
"method to try out :func:`~flask.url_for`. "
":meth:`~flask.Flask.test_request_context` tells Flask to behave as though"
" it's handling a request even while we use a Python shell. See :ref"
":`context-locals`."
msgstr ""
"به عنوان مثال، در اینجا از روش :meth:`~flask.Flask.test_request_context` "
"برای امتحان کردن :func:`~flask.url_for` استفاده می کنیم. "
":meth:`~flask.Flask.test_request_context` به Flask می گوید که به گونه ای "
"رفتار کند که انگار در حال رسیدگی به یک درخواست است حتی زمانی که ما از "
"پوسته پایتون استفاده می کنیم. به :ref:`context-locals` مراجعه کنید."

#: ../../quickstart.rst:361
msgid "HTTP Methods"
msgstr "متود های HTTP"

#: ../../quickstart.rst:363
msgid ""
"Web applications use different HTTP methods when accessing URLs. You "
"should familiarize yourself with the HTTP methods as you work with Flask."
" By default, a route only answers to ``GET`` requests. You can use the "
"``methods`` argument of the :meth:`~flask.Flask.route` decorator to "
"handle different HTTP methods. ::"
msgstr ""
"برنامه های کاربردی وب هنگام دسترسی به URL ها از روش های مختلف HTTP "
"استفاده می کنند. هنگام کار با فلاسک باید با روش های HTTP آشنا شوید. به "
"طور پیش‌فرض، یک مسیر فقط به درخواست‌های ``GET`` پاسخ می‌دهد. می‌توانید از"
" آرگومان``methods`` دکوراتور :meth:`~flask.Flask.route` برای مدیریت "
"روش‌های مختلف HTTP استفاده کنید. ::"

#: ../../quickstart.rst:378
msgid ""
"If ``GET`` is present, Flask automatically adds support for the ``HEAD`` "
"method and handles ``HEAD`` requests according to the `HTTP RFC`_. "
"Likewise, ``OPTIONS`` is automatically implemented for you."
msgstr ""
"اگر ``GET`` وجود داشته باشد، فلاسک به طور خودکار از روش ``HEAD`` پشتیبانی"
" می‌کند و درخواست‌های «HEAD» را مطابق با `HTTP RFC`_ مدیریت می‌کند. به "
"همین ترتیب، ``OPTIONS`` به طور خودکار برای شما پیاده سازی می شود."

#: ../../quickstart.rst:385
msgid "Static Files"
msgstr "فایل های استاتیک"

#: ../../quickstart.rst:387
msgid ""
"Dynamic web applications also need static files.  That's usually where "
"the CSS and JavaScript files are coming from.  Ideally your web server is"
" configured to serve them for you, but during development Flask can do "
"that as well.  Just create a folder called :file:`static` in your package"
" or next to your module and it will be available at ``/static`` on the "
"application."
msgstr ""
"برنامه های وب پویا به فایل های استاتیک نیز نیاز دارند. معمولاً فایل های "
"CSS و جاوا اسکریپت از آنجا می آیند. در حالت ایده آل وب سرور شما به گونه "
"ای پیکربندی شده است که آنها را برای شما ارائه دهد، اما در حین توسعه، "
"فلاسک می تواند این کار را نیز انجام داد. فقط یک پوشه به نام "
":file:`static` در پکیج خود یا در کنار ماژول خود ایجاد کنید و در آدرس "
"``/static`` در برنامه در دسترس خواهد بود."

# endpoint: نقطه پایانی
#: ../../quickstart.rst:393
msgid ""
"To generate URLs for static files, use the special ``'static'`` endpoint "
"name::"
msgstr ""
"برای ایجاد URL برای فایل‌های استاتیک، از نام نقطه پایانی ویژه "
"``'static'`` استفاده کنید::"

#: ../../quickstart.rst:397
msgid "The file has to be stored on the filesystem as :file:`static/style.css`."
msgstr "فایل باید در سیستم فایل به صورت:file:`static/style.css`. ذخیره شود."

#: ../../quickstart.rst:400
msgid "Rendering Templates"
msgstr "الگوهای رندرینگ"

#: ../../quickstart.rst:402
msgid ""
"Generating HTML from within Python is not fun, and actually pretty "
"cumbersome because you have to do the HTML escaping on your own to keep "
"the application secure.  Because of that Flask configures the `Jinja2 "
"<https://palletsprojects.com/p/jinja/>`_ template engine for you "
"automatically."
msgstr ""
"تولید HTML از داخل پایتون سرگرم کننده نیست، و در واقع بسیار دست و پا گیر "
"است، زیرا برای ایمن نگه داشتن برنامه، باید HTML را به تنهایی انجام دهید. "
"به همین دلیل فلاسک موتور قالب `Jinja2 "
"<https://palletsprojects.com/p/jinja/>`_ را به طور خودکار برای شما "
"پیکربندی می کند."

#: ../../quickstart.rst:407
msgid ""
"To render a template you can use the :func:`~flask.render_template` "
"method.  All you have to do is provide the name of the template and the "
"variables you want to pass to the template engine as keyword arguments. "
"Here's a simple example of how to render a template::"
msgstr ""
"برای رندر یک الگو می توانید از روش :func:`~flask.render_template` استفاده"
" کنید. تنها کاری که باید انجام دهید این است که نام قالب و متغیرهایی را که"
" می خواهید به عنوان آرگومان های کلمه کلیدی به موتور قالب منتقل کنید، "
"ارائه دهید. در اینجا یک مثال ساده از نحوه ارائه یک الگو آورده شده است:"

#: ../../quickstart.rst:419
msgid ""
"Flask will look for templates in the :file:`templates` folder.  So if "
"your application is a module, this folder is next to that module, if it's"
" a package it's actually inside your package:"
msgstr ""
"فلاسک دارای مقادیر زیادی از پیکربندی با پیش فرض های معقول، و چند قرارداد "
"در هنگام شروع است. طبق قرارداد، قالب‌ها و فایل‌های استاتیک در زیرشاخه‌های"
" منبع برنامه، با نام‌ های :file:`templates` و :file:`static` ذخیره "
"می‌شوند. البته میتوان آنها را تغییر داد ولی معمولا به خصوص در هنگام شروع "
"مجبور نیستید که آنها را تغییر دهید:"

#: ../../quickstart.rst:423
msgid "**Case 1**: a module::"
msgstr "**مورد ۱**: یک ماژول::"

#: ../../quickstart.rst:429
msgid "**Case 2**: a package::"
msgstr "**مورد ۲**: یک ماژول::"

#: ../../quickstart.rst:436
msgid ""
"For templates you can use the full power of Jinja2 templates.  Head over "
"to the official `Jinja2 Template Documentation "
"<https://jinja.palletsprojects.com/templates/>`_ for more information."
msgstr ""
"برای قالب ها می توانید از قدرت کامل قالب های Jinja2 استفاده کنید. برای "
"اطلاعات بیشتر به ` `مستندات الگوی jinja2 "
"<https://jinja.palletsprojects.com/templates/>`_ <مراجعه کنید."

#: ../../quickstart.rst:440
msgid "Here is an example template:"
msgstr ""

#: ../../quickstart.rst:452
msgid ""
"Inside templates you also have access to the :data:`~flask.Flask.config`,"
" :class:`~flask.request`, :class:`~flask.session` and :class:`~flask.g` "
"[#]_ objects as well as the :func:`~flask.url_for` and "
":func:`~flask.get_flashed_messages` functions."
msgstr ""
"در داخل الگوها همچنین به :data:`~flask.Flask.config`, "
":class:`~flask.request`, :class:`~flask.session` و :class:`~flask.g` [#]_"
"  و همچنین به توابع :func:`~flask.url_for`  و "
":func:`~flask.get_flashed_messages` دسترسی دارید."

#: ../../quickstart.rst:456
msgid ""
"Templates are especially useful if inheritance is used.  If you want to "
"know how that works, see :doc:`patterns/templateinheritance`. Basically "
"template inheritance makes it possible to keep certain elements on each "
"page (like header, navigation and footer)."
msgstr ""
"اگر از وراثت استفاده میکنید.، الگوها بسیار مفید هستند. اگر می خواهید "
"بدانید که چگونه کار می کند، به :doc:`patterns/templateinheritance` مراجعه"
" کنید. اساساً، وراثت قالب، نگه داشتن عناصر خاصی را در هر صفحه (مانند هدر،"
" ناوبری و پاورقی) ممکن می‌سازد."

# خنثی:escape
#: ../../quickstart.rst:461
msgid ""
"Automatic escaping is enabled, so if ``name`` contains HTML it will be "
"escaped automatically.  If you can trust a variable and you know that it "
"will be safe HTML (for example because it came from a module that "
"converts wiki markup to HTML) you can mark it as safe by using the "
":class:`~markupsafe.Markup` class or by using the ``|safe`` filter in the"
" template.  Head over to the Jinja 2 documentation for more examples."
msgstr ""
"فرار خودکار فعال است، بنابراین اگر ``name`` حاوی HTML باشد، به طور خودکار"
" از آن خنثی میکند. اگر می‌توانید به متغیری اعتماد کنید و می‌دانید که HTML"
" ایمن خواهد بود (مثلاً چون از ماژولی است که نشانه‌گذاری ویکی را به HTML "
"تبدیل می‌کند)، می‌توانید با استفاده از کلاس :class:`~markupsafe.Markup`  "
"آن را به عنوان امن علامت‌گذاری کنید. یا با استفاده از فیلتر ``|safe`` در "
"الگو اینکار را انجام دهید. برای نمونه های بیشتر به مستندات Jinja 2 بروید."

#: ../../quickstart.rst:468
msgid ""
"Here is a basic introduction to how the :class:`~markupsafe.Markup` class"
" works::"
msgstr ""
"در اینجا یک مقدمه اولیه برای نحوه عملکرد کلاس :class:`~markupsafe.Markup`"
" آورده شده است::"

# فرارخودکار:autoescaping
#: ../../quickstart.rst:480
msgid ""
"Autoescaping is no longer enabled for all templates.  The following "
"extensions for templates trigger autoescaping: ``.html``, ``.htm``, "
"``.xml``, ``.xhtml``.  Templates loaded from a string will have "
"autoescaping disabled."
msgstr ""
"فرار خودکار دیگر برای همه الگوها فعال نیست. فرار خودکار برای پسوند های "
"زیر انجام میشود: : ``.html``, ``.htm``, ``.xml``, ``.xhtml``. الگوهای "
"بارگذاری شده از یک رشته، فرار خودکار را غیر فعال خواهد کرد."

#: ../../quickstart.rst:485
msgid ""
"Unsure what that :class:`~flask.g` object is? It's something in which you"
" can store information for your own needs. See the documentation for "
":class:`flask.g` and :doc:`patterns/sqlite3`."
msgstr ""
"اطمینان ندارید که شی :class:`~flask.g` چیست؟ این چیزی است که در آن می "
"توانید اطلاعات را برای نیازهای خود ذخیره کنید. برای اطلاعات بیشتر به "
"مستندات :class:`flask.g` و :doc:`patterns/sqlite3` مراجعه کنید."

#: ../../quickstart.rst:491
msgid "Accessing Request Data"
msgstr "دسترسی به داده های درخواستی"

#: ../../quickstart.rst:493
msgid ""
"For web applications it's crucial to react to the data a client sends to "
"the server.  In Flask this information is provided by the global "
":class:`~flask.request` object.  If you have some experience with Python "
"you might be wondering how that object can be global and how Flask "
"manages to still be threadsafe.  The answer is context locals:"
msgstr ""
"برای برنامه های کاربردی وب، بسیار مهم است که به داده هایی که مشتری به "
"سرور ارسال می کند واکنش نشان دهد. در فلاسک این اطلاعات توسط شیء سراسری "
":class:`~flask.request` ارائه می شود. اگر تجربه‌ای با پایتون دارید، ممکن "
"است تعجب کنید که چگونه آن شی می‌تواند سراسری باشد و چگونه فلاسک می‌تواند "
"همچنان امن باشد. پاسخ متن محلی است:"

#: ../../quickstart.rst:503
msgid "Context Locals"
msgstr "متن محلی"

#: ../../quickstart.rst:505
msgid "Insider Information"
msgstr "اطلاعات داخلی"

#: ../../quickstart.rst:507
msgid ""
"If you want to understand how that works and how you can implement tests "
"with context locals, read this section, otherwise just skip it."
msgstr ""
"اگر می‌خواهید بدانید که چگونه کار می‌کند و چگونه می‌توانید آزمایش‌ها را "
"با متن محلی پیاده‌سازی کنید، این بخش را بخوانید، در غیر این صورت فقط آن "
"را نادیده بگیرید."

#: ../../quickstart.rst:510
msgid ""
"Certain objects in Flask are global objects, but not of the usual kind. "
"These objects are actually proxies to objects that are local to a "
"specific context.  What a mouthful.  But that is actually quite easy to "
"understand."
msgstr ""

#: ../../quickstart.rst:514
msgid ""
"Imagine the context being the handling thread.  A request comes in and "
"the web server decides to spawn a new thread (or something else, the "
"underlying object is capable of dealing with concurrency systems other "
"than threads).  When Flask starts its internal request handling it "
"figures out that the current thread is the active context and binds the "
"current application and the WSGI environments to that context (thread). "
"It does that in an intelligent way so that one application can invoke "
"another application without breaking."
msgstr ""

#: ../../quickstart.rst:523
msgid ""
"So what does this mean to you?  Basically you can completely ignore that "
"this is the case unless you are doing something like unit testing.  You "
"will notice that code which depends on a request object will suddenly "
"break because there is no request object.  The solution is creating a "
"request object yourself and binding it to the context.  The easiest "
"solution for unit testing is to use the "
":meth:`~flask.Flask.test_request_context` context manager.  In "
"combination with the ``with`` statement it will bind a test request so "
"that you can interact with it.  Here is an example::"
msgstr ""

#: ../../quickstart.rst:540
msgid ""
"The other possibility is passing a whole WSGI environment to the "
":meth:`~flask.Flask.request_context` method::"
msgstr ""

#: ../../quickstart.rst:547
msgid "The Request Object"
msgstr ""

#: ../../quickstart.rst:549
msgid ""
"The request object is documented in the API section and we will not cover"
" it here in detail (see :class:`~flask.Request`). Here is a broad "
"overview of some of the most common operations.  First of all you have to"
" import it from the ``flask`` module::"
msgstr ""

#: ../../quickstart.rst:556
msgid ""
"The current request method is available by using the "
":attr:`~flask.Request.method` attribute.  To access form data (data "
"transmitted in a ``POST`` or ``PUT`` request) you can use the "
":attr:`~flask.Request.form` attribute.  Here is a full example of the two"
" attributes mentioned above::"
msgstr ""

#: ../../quickstart.rst:575
msgid ""
"What happens if the key does not exist in the ``form`` attribute?  In "
"that case a special :exc:`KeyError` is raised.  You can catch it like a "
"standard :exc:`KeyError` but if you don't do that, a HTTP 400 Bad Request"
" error page is shown instead.  So for many situations you don't have to "
"deal with that problem."
msgstr ""

#: ../../quickstart.rst:581
msgid ""
"To access parameters submitted in the URL (``?key=value``) you can use "
"the :attr:`~flask.Request.args` attribute::"
msgstr ""

#: ../../quickstart.rst:586
msgid ""
"We recommend accessing URL parameters with `get` or by catching the "
":exc:`KeyError` because users might change the URL and presenting them a "
"400 bad request page in that case is not user friendly."
msgstr ""

#: ../../quickstart.rst:590
msgid ""
"For a full list of methods and attributes of the request object, head "
"over to the :class:`~flask.Request` documentation."
msgstr ""

#: ../../quickstart.rst:595
msgid "File Uploads"
msgstr ""

#: ../../quickstart.rst:597
msgid ""
"You can handle uploaded files with Flask easily.  Just make sure not to "
"forget to set the ``enctype=\"multipart/form-data\"`` attribute on your "
"HTML form, otherwise the browser will not transmit your files at all."
msgstr ""

#: ../../quickstart.rst:601
msgid ""
"Uploaded files are stored in memory or at a temporary location on the "
"filesystem.  You can access those files by looking at the "
":attr:`~flask.request.files` attribute on the request object.  Each "
"uploaded file is stored in that dictionary.  It behaves just like a "
"standard Python :class:`file` object, but it also has a "
":meth:`~werkzeug.datastructures.FileStorage.save` method that allows you "
"to store that file on the filesystem of the server. Here is a simple "
"example showing how that works::"
msgstr ""

#: ../../quickstart.rst:619
msgid ""
"If you want to know how the file was named on the client before it was "
"uploaded to your application, you can access the "
":attr:`~werkzeug.datastructures.FileStorage.filename` attribute. However "
"please keep in mind that this value can be forged so never ever trust "
"that value.  If you want to use the filename of the client to store the "
"file on the server, pass it through the "
":func:`~werkzeug.utils.secure_filename` function that Werkzeug provides "
"for you::"
msgstr ""

#: ../../quickstart.rst:637
msgid "For some better examples, see :doc:`patterns/fileuploads`."
msgstr ""

#: ../../quickstart.rst:640
msgid "Cookies"
msgstr ""

#: ../../quickstart.rst:642
msgid ""
"To access cookies you can use the :attr:`~flask.Request.cookies` "
"attribute.  To set cookies you can use the "
":attr:`~flask.Response.set_cookie` method of response objects.  The "
":attr:`~flask.Request.cookies` attribute of request objects is a "
"dictionary with all the cookies the client transmits.  If you want to use"
" sessions, do not use the cookies directly but instead use the "
":ref:`sessions` in Flask that add some security on top of cookies for "
"you."
msgstr ""

#: ../../quickstart.rst:650
msgid "Reading cookies::"
msgstr ""

#: ../../quickstart.rst:660
msgid "Storing cookies::"
msgstr ""

#: ../../quickstart.rst:670
msgid ""
"Note that cookies are set on response objects.  Since you normally just "
"return strings from the view functions Flask will convert them into "
"response objects for you.  If you explicitly want to do that you can use "
"the :meth:`~flask.make_response` function and then modify it."
msgstr ""

#: ../../quickstart.rst:675
msgid ""
"Sometimes you might want to set a cookie at a point where the response "
"object does not exist yet.  This is possible by utilizing the "
":doc:`patterns/deferredcallbacks` pattern."
msgstr ""

#: ../../quickstart.rst:679
msgid "For this also see :ref:`about-responses`."
msgstr ""

#: ../../quickstart.rst:682
msgid "Redirects and Errors"
msgstr ""

#: ../../quickstart.rst:684
msgid ""
"To redirect a user to another endpoint, use the :func:`~flask.redirect` "
"function; to abort a request early with an error code, use the "
":func:`~flask.abort` function::"
msgstr ""

#: ../../quickstart.rst:699
msgid ""
"This is a rather pointless example because a user will be redirected from"
" the index to a page they cannot access (401 means access denied) but it "
"shows how that works."
msgstr ""

#: ../../quickstart.rst:703
msgid ""
"By default a black and white error page is shown for each error code.  If"
" you want to customize the error page, you can use the "
":meth:`~flask.Flask.errorhandler` decorator::"
msgstr ""

#: ../../quickstart.rst:713
msgid ""
"Note the ``404`` after the :func:`~flask.render_template` call.  This "
"tells Flask that the status code of that page should be 404 which means "
"not found.  By default 200 is assumed which translates to: all went well."
msgstr ""

#: ../../quickstart.rst:717
msgid "See :doc:`errorhandling` for more details."
msgstr ""

#: ../../quickstart.rst:722
msgid "About Responses"
msgstr ""

#: ../../quickstart.rst:724
msgid ""
"The return value from a view function is automatically converted into a "
"response object for you. If the return value is a string it's converted "
"into a response object with the string as response body, a ``200 OK`` "
"status code and a :mimetype:`text/html` mimetype. If the return value is "
"a dict, :func:`jsonify` is called to produce a response. The logic that "
"Flask applies to converting return values into response objects is as "
"follows:"
msgstr ""

#: ../../quickstart.rst:732
msgid ""
"If a response object of the correct type is returned it's directly "
"returned from the view."
msgstr ""

#: ../../quickstart.rst:734
msgid ""
"If it's a string, a response object is created with that data and the "
"default parameters."
msgstr ""

#: ../../quickstart.rst:736
msgid "If it's a dict, a response object is created using ``jsonify``."
msgstr ""

#: ../../quickstart.rst:737
msgid ""
"If a tuple is returned the items in the tuple can provide extra "
"information. Such tuples have to be in the form ``(response, status)``, "
"``(response, headers)``, or ``(response, status, headers)``. The "
"``status`` value will override the status code and ``headers`` can be a "
"list or dictionary of additional header values."
msgstr ""

#: ../../quickstart.rst:743
msgid ""
"If none of that works, Flask will assume the return value is a valid WSGI"
" application and convert that into a response object."
msgstr ""

#: ../../quickstart.rst:746
msgid ""
"If you want to get hold of the resulting response object inside the view "
"you can use the :func:`~flask.make_response` function."
msgstr ""

#: ../../quickstart.rst:749
msgid "Imagine you have a view like this::"
msgstr ""

#: ../../quickstart.rst:757
msgid ""
"You just need to wrap the return expression with "
":func:`~flask.make_response` and get the response object to modify it, "
"then return it::"
msgstr ""

#: ../../quickstart.rst:771
msgid "APIs with JSON"
msgstr ""

#: ../../quickstart.rst:773
msgid ""
"A common response format when writing an API is JSON. It's easy to get "
"started writing such an API with Flask. If you return a ``dict`` from a "
"view, it will be converted to a JSON response."
msgstr ""

#: ../../quickstart.rst:788
msgid ""
"Depending on your API design, you may want to create JSON responses for "
"types other than ``dict``. In that case, use the "
":func:`~flask.json.jsonify` function, which will serialize any supported "
"JSON data type. Or look into Flask community extensions that support more"
" complex applications."
msgstr ""

#: ../../quickstart.rst:807
msgid "Sessions"
msgstr ""

#: ../../quickstart.rst:809
msgid ""
"In addition to the request object there is also a second object called "
":class:`~flask.session` which allows you to store information specific to"
" a user from one request to the next.  This is implemented on top of "
"cookies for you and signs the cookies cryptographically.  What this means"
" is that the user could look at the contents of your cookie but not "
"modify it, unless they know the secret key used for signing."
msgstr ""

#: ../../quickstart.rst:816
msgid ""
"In order to use sessions you have to set a secret key.  Here is how "
"sessions work::"
msgstr ""

#: ../../quickstart.rst:848
msgid "How to generate good secret keys"
msgstr ""

#: ../../quickstart.rst:850
msgid ""
"A secret key should be as random as possible. Your operating system has "
"ways to generate pretty random data based on a cryptographic random "
"generator. Use the following command to quickly generate a value for "
":attr:`Flask.secret_key` (or :data:`SECRET_KEY`)::"
msgstr ""

#: ../../quickstart.rst:858
msgid ""
"A note on cookie-based sessions: Flask will take the values you put into "
"the session object and serialize them into a cookie.  If you are finding "
"some values do not persist across requests, cookies are indeed enabled, "
"and you are not getting a clear error message, check the size of the "
"cookie in your page responses compared to the size supported by web "
"browsers."
msgstr ""

#: ../../quickstart.rst:864
msgid ""
"Besides the default client-side based sessions, if you want to handle "
"sessions on the server-side instead, there are several Flask extensions "
"that support this."
msgstr ""

#: ../../quickstart.rst:869
msgid "Message Flashing"
msgstr ""

#: ../../quickstart.rst:871
msgid ""
"Good applications and user interfaces are all about feedback.  If the "
"user does not get enough feedback they will probably end up hating the "
"application.  Flask provides a really simple way to give feedback to a "
"user with the flashing system.  The flashing system basically makes it "
"possible to record a message at the end of a request and access it on the"
" next (and only the next) request.  This is usually combined with a "
"layout template to expose the message."
msgstr ""

#: ../../quickstart.rst:879
msgid ""
"To flash a message use the :func:`~flask.flash` method, to get hold of "
"the messages you can use :func:`~flask.get_flashed_messages` which is "
"also available in the templates. See :doc:`patterns/flashing` for a full "
"example."
msgstr ""

#: ../../quickstart.rst:885
#, fuzzy
msgid "Logging"
msgstr ""
":doc:`/logging` و :doc:`/errorhandling` را برای لاگ های ارور و نمایش بهتر"
" صفحات ارور ببینید."

#: ../../quickstart.rst:889
msgid ""
"Sometimes you might be in a situation where you deal with data that "
"should be correct, but actually is not.  For example you may have some "
"client-side code that sends an HTTP request to the server but it's "
"obviously malformed.  This might be caused by a user tampering with the "
"data, or the client code failing.  Most of the time it's okay to reply "
"with ``400 Bad Request`` in that situation, but sometimes that won't do "
"and the code has to continue working."
msgstr ""

#: ../../quickstart.rst:897
msgid ""
"You may still want to log that something fishy happened.  This is where "
"loggers come in handy.  As of Flask 0.3 a logger is preconfigured for you"
" to use."
msgstr ""

#: ../../quickstart.rst:901
msgid "Here are some example log calls::"
msgstr ""

#: ../../quickstart.rst:907
msgid ""
"The attached :attr:`~flask.Flask.logger` is a standard logging "
":class:`~logging.Logger`, so head over to the official :mod:`logging` "
"docs for more information."
msgstr ""

#: ../../quickstart.rst:911
msgid "See :doc:`errorhandling`."
msgstr ""

#: ../../quickstart.rst:915
msgid "Hooking in WSGI Middleware"
msgstr ""

#: ../../quickstart.rst:917
msgid ""
"To add WSGI middleware to your Flask application, wrap the application's "
"``wsgi_app`` attribute. For example, to apply Werkzeug's "
":class:`~werkzeug.middleware.proxy_fix.ProxyFix` middleware for running "
"behind Nginx:"
msgstr ""

#: ../../quickstart.rst:927
msgid ""
"Wrapping ``app.wsgi_app`` instead of ``app`` means that ``app`` still "
"points at your Flask application, not at the middleware, so you can "
"continue to use and configure ``app`` directly."
msgstr ""

#: ../../quickstart.rst:932
msgid "Using Flask Extensions"
msgstr ""

#: ../../quickstart.rst:934
msgid ""
"Extensions are packages that help you accomplish common tasks. For "
"example, Flask-SQLAlchemy provides SQLAlchemy support that makes it "
"simple and easy to use with Flask."
msgstr ""

#: ../../quickstart.rst:938
msgid "For more on Flask extensions, see :doc:`extensions`."
msgstr ""

#: ../../quickstart.rst:941
#, fuzzy
msgid "Deploying to a Web Server"
msgstr "وب را  با احتیاط توسعه دهید"

#: ../../quickstart.rst:943
msgid "Ready to deploy your new Flask app? See :doc:`deploying/index`."
msgstr ""

#~ msgid "The interactive debugger in action."
#~ msgstr "اشکال زدای تعاملی در عمل."
