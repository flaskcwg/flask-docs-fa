# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets
# This file is distributed under the same license as the Flask package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: Flask 2.1.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-12-08 08:56+0330\n"
"PO-Revision-Date: 2021-12-14 16:35+0330\n"
"Language-Team: fa <ahmdparsh129@gmail.com>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=2; plural=(n==0 || n==1);\n"
"Last-Translator:  Mohamad Balkhi  <ahmdparsh129@gmail.com>\n"
"Language: fa\n"
"X-Generator: Poedit 3.0\n"

#: ../../tutorial/views.rst:4
msgid "Blueprints and Views"
msgstr "نقشه ها و نماها(Blueprints and Views)"

#: ../../tutorial/views.rst:6
msgid ""
"A view function is the code you write to respond to requests to your "
"application. Flask uses patterns to match the incoming request URL to the "
"view that should handle it. The view returns data that Flask turns into an "
"outgoing response. Flask can also go the other direction and generate a URL "
"to a view based on its name and arguments."
msgstr ""
"تابع view کدی است که شما برای پاسخ به درخواست های برنامه خود می نویسید. فلاسک "
"از الگوهایی برای تطبیق URL درخواست ورودی با نمای مورد نظر استفاده می کند. "
"View داده‌هایی را برمی‌گرداند که فلاسک به یک پاسخ خروجی تبدیل می‌کند. فلاسک "
"همچنین می تواند جهت دیگری را برود و یک URL برای یک view بر اساس نام و آرگومان "
"های آن ایجاد کند."

#: ../../tutorial/views.rst:14
msgid "Create a Blueprint"
msgstr "ساخت یک طرح اولیه"

#: ../../tutorial/views.rst:16
msgid ""
"A :class:`Blueprint` is a way to organize a group of related views and other "
"code. Rather than registering views and other code directly with an "
"application, they are registered with a blueprint. Then the blueprint is "
"registered with the application when it is available in the factory function."
msgstr ""
"A :class:`Blueprint` راهی برای سازماندهی گروهی از نماهای مرتبط و کدهای دیگر "
"است. به جای ثبت نماها و سایر کدها به طور مستقیم با یک برنامه، آنها با یک نقشه "
"ثبت می شوند. سپس طرح اولیه هنگامی که در عملکرد کارخانه در دسترس باشد با "
"برنامه ثبت می شود."

#: ../../tutorial/views.rst:22
msgid ""
"Flaskr will have two blueprints, one for authentication functions and one for "
"the blog posts functions. The code for each blueprint will go in a separate "
"module. Since the blog needs to know about authentication, you'll write the "
"authentication one first."
msgstr ""
"Flaskr دو طرح دارد، یکی برای توابع احراز هویت و دیگری برای توابع پست های "
"وبلاگ. کد هر طرح در یک ماژول جداگانه خواهد بود. از آنجایی که وبلاگ باید در "
"مورد احراز هویت اطلاعات داشته باشد، ابتدا یک احراز هویت را بنویسید."

#: ../../tutorial/views.rst:27 ../../tutorial/views.rst:79
#: ../../tutorial/views.rst:170 ../../tutorial/views.rst:222
#: ../../tutorial/views.rst:251 ../../tutorial/views.rst:267
msgid "``flaskr/auth.py``"
msgstr "``flaskr/auth.py``"

#: ../../tutorial/views.rst:41
msgid ""
"This creates a :class:`Blueprint` named ``'auth'``. Like the application "
"object, the blueprint needs to know where it's defined, so ``__name__`` is "
"passed as the second argument. The ``url_prefix`` will be prepended to all "
"the URLs associated with the blueprint."
msgstr ""
"این یک :class:`Blueprint` با نام ``auth`` ایجاد می کند. مانند شی برنامه، طرح "
"اولیه باید بداند کجا تعریف شده است، بنابراین ``__name__`` به عنوان آرگومان "
"دوم ارسال می شود. ``url_prefix`` به تمام URL های مرتبط با طرح اولیه اضافه می "
"شود."

#: ../../tutorial/views.rst:46
msgid ""
"Import and register the blueprint from the factory using :meth:`app."
"register_blueprint() <Flask.register_blueprint>`. Place the new code at the "
"end of the factory function before returning the app."
msgstr ""
"با استفاده از :meth:`app.register_blueprint() <Flask.register_blueprint>` طرح "
"اولیه را از کارخانه وارد و ثبت کنید. قبل از بازگرداندن برنامه، کد جدید را در "
"انتهای عملکرد کارخانه قرار دهید."

#: ../../tutorial/views.rst:50
msgid "``flaskr/__init__.py``"
msgstr "``flaskr/__init__.py``"

#: ../../tutorial/views.rst:62
msgid ""
"The authentication blueprint will have views to register new users and to log "
"in and log out."
msgstr ""
"طرح احراز هویت دارای نماهایی برای ثبت نام کاربران جدید و ورود و خروج از سیستم "
"است."

#: ../../tutorial/views.rst:67
msgid "The First View: Register"
msgstr "نمای اول: ثبت نام"

#: ../../tutorial/views.rst:69
msgid ""
"When the user visits the ``/auth/register`` URL, the ``register`` view will "
"return `HTML`_ with a form for them to fill out. When they submit the form, "
"it will validate their input and either show the form again with an error "
"message or create the new user and go to the login page."
msgstr ""
"هنگامی که کاربر از نشانی اینترنتی ``/auth/register`` بازدید می کند، "
"نمای``register``، `HTML`_ را همراه با فرمی برای پر کردن آن برمی گرداند. "
"هنگامی که آنها فرم را ارسال می کنند، ورودی آنها را تأیید می کند و یا دوباره "
"فرم را با پیام خطا نشان می دهد یا کاربر جدید را ایجاد می کند و به صفحه ورود "
"می رود."

#: ../../tutorial/views.rst:76
msgid ""
"For now you will just write the view code. On the next page, you'll write "
"templates to generate the HTML form."
msgstr ""
"در حال حاضر شما فقط کد نما را می نویسید. در صفحه بعد، الگوهایی را برای تولید "
"فرم HTML خواهید نوشت."

#: ../../tutorial/views.rst:111
msgid "Here's what the ``register`` view function is doing:"
msgstr "در اینجا عملکرد تابع نمای ``register`` بررسی می شود :"

#: ../../tutorial/views.rst:113
msgid ""
":meth:`@bp.route <Blueprint.route>` associates the URL ``/register`` with the "
"``register`` view function. When Flask receives a request to ``/auth/"
"register``, it will call the ``register`` view and use the return value as "
"the response."
msgstr ""
":meth:`@bp.route <Blueprint.route>` شانی اینترنتی ``/register`` را با عملکرد "
"نمای ``register`` مرتبط می کند. هنگامی که فلاسک درخواستی برای ``/auth/"
"register`` دریافت می کند، نمای ``register`` را فراخوانی می کند و از مقدار "
"بازگشتی به عنوان پاسخ استفاده می کند."

#: ../../tutorial/views.rst:118
msgid ""
"If the user submitted the form, :attr:`request.method <Request.method>` will "
"be ``'POST'``. In this case, start validating the input."
msgstr ""
"اگر کاربر فرم را ارسال کرده باشد، :attr:`request.method <Request.method>` "
"خواهد بود. در این حالت، اعتبار ورودی را شروع کنید."

#: ../../tutorial/views.rst:122
msgid ""
":attr:`request.form <Request.form>` is a special type of :class:`dict` "
"mapping submitted form keys and values. The user will input their "
"``username`` and ``password``."
msgstr ""
":attr:`request.form <Request.form>` نوع خاصی از :class:`dict` نگاشت کلیدها و "
"مقادیر فرم ارسال شده است. کاربر ``username`` و ``password`` خود را وارد می "
"کند."

#: ../../tutorial/views.rst:126
msgid "Validate that ``username`` and ``password`` are not empty."
msgstr "تأیید کنید که ``username`` و ``password`` خالی نیستند."

#: ../../tutorial/views.rst:128
msgid "If validation succeeds, insert the new user data into the database."
msgstr ""
"در صورت موفقیت آمیز بودن اعتبارسنجی، داده های کاربر جدید را در پایگاه داده "
"وارد کنید."

#: ../../tutorial/views.rst:130
msgid ""
":meth:`db.execute <sqlite3.Connection.execute>` takes a SQL query with ``?`` "
"placeholders for any user input, and a tuple of values to replace the "
"placeholders with. The database library will take care of escaping the values "
"so you are not vulnerable to a *SQL injection attack*."
msgstr ""
":meth:`db.execute <sqlite3.Connection.execute>` برای هر ورودی کاربر یک کوئری "
"SQL با متغیرهای ``?`` می دهد و چندین مقدار را جایگزین می کند. کتابخانه پایگاه "
"داده از تزریق کد SQL فرار می کند تا شما در برابر حمله *SQL injection* آسیب "
"پذیر نباشید."

#: ../../tutorial/views.rst:136
msgid ""
"For security, passwords should never be stored in the database directly. "
"Instead, :func:`~werkzeug.security.generate_password_hash` is used to "
"securely hash the password, and that hash is stored. Since this query "
"modifies data, :meth:`db.commit() <sqlite3.Connection.commit>` needs to be "
"called afterwards to save the changes."
msgstr ""
"برای امنیت، رمزهای عبور هرگز نباید مستقیماً در پایگاه داده ذخیره شوند. در "
"عوض، :func:`~werkzeug.security.generate_password_hash` برای هش ایمن رمز عبور "
"استفاده می شود و آن هش ذخیره می شود. از آنجایی که این کوئری داده ها را تغییر "
"می دهد، :meth:`db.commit() <sqlite3.Connection.commit>` باید پس از آن برای "
"ذخیره تغییرات فراخوانی شود."

#: ../../tutorial/views.rst:144
msgid ""
"An :exc:`sqlite3.IntegrityError` will occur if the username already exists, "
"which should be shown to the user as another validation error."
msgstr ""
"اگر نام کاربری قبلاً وجود داشته باشد، یک :exc:`sqlite3.IntegrityError` رخ "
"خواهد داد که باید به عنوان یک خطای اعتبارسنجی دیگر به کاربر نشان داده شود."

#: ../../tutorial/views.rst:148
msgid ""
"After storing the user, they are redirected to the login page. :func:"
"`url_for` generates the URL for the login view based on its name. This is "
"preferable to writing the URL directly as it allows you to change the URL "
"later without changing all code that links to it. :func:`redirect` generates "
"a redirect response to the generated URL."
msgstr ""
"پس از ذخیره سازی کاربر، آنها به صفحه ورود هدایت می شوند. :func:`url_for` ، "
"URL را برای نمای ورود بر اساس نام آن ایجاد می کند. این برای نوشتن مستقیم URL "
"ترجیح داده می شود زیرا به شما امکان می دهد URL را بعداً بدون تغییر همه کدهایی "
"که به آن پیوند می دهند تغییر دهید. :func:`redirect` یک پاسخ تغییر مسیر به URL "
"تولید شده ایجاد می کند."

#: ../../tutorial/views.rst:155
msgid ""
"If validation fails, the error is shown to the user. :func:`flash` stores "
"messages that can be retrieved when rendering the template."
msgstr ""
"اگر اعتبارسنجی ناموفق باشد، خطا به کاربر نشان داده می شود. :func:`flash` "
"پیام‌هایی را ذخیره می‌کند که می‌توان آنها را هنگام رندر کردن الگو بازیابی کرد."

#: ../../tutorial/views.rst:158
msgid ""
"When the user initially navigates to ``auth/register``, or there was a "
"validation error, an HTML page with the registration form should be shown. :"
"func:`render_template` will render a template containing the HTML, which "
"you'll write in the next step of the tutorial."
msgstr ""
"هنگامی که کاربر در ابتدا به ``auth/register`` می‌رود، یا یک خطای اعتبارسنجی "
"وجود دارد، یک صفحه HTML با فرم ثبت نام باید نشان داده شود. :func:"
"`render_template`  یک قالب حاوی HTML را ارائه می دهد که در مرحله بعدی آموزش "
"آن را می نویسید."

#: ../../tutorial/views.rst:166
msgid "Login"
msgstr "ورود به حساب کاربری"

#: ../../tutorial/views.rst:168
msgid "This view follows the same pattern as the ``register`` view above."
msgstr "این نمای از همان الگوی نمای``register``  در بالا پیروی می کند."

#: ../../tutorial/views.rst:198
msgid "There are a few differences from the ``register`` view:"
msgstr "چند تفاوت با نمای ``register`` وجود دارد:"

#: ../../tutorial/views.rst:200
msgid "The user is queried first and stored in a variable for later use."
msgstr "کاربر ابتدا و در یک متغیر برای استفاده بعدی ذخیره می شود."

#: ../../tutorial/views.rst:202
msgid ""
":meth:`~sqlite3.Cursor.fetchone` returns one row from the query. If the query "
"returned no results, it returns ``None``. Later, :meth:`~sqlite3.Cursor."
"fetchall` will be used, which returns a list of all results."
msgstr ""
":meth:`~sqlite3.Cursor.fetchone` یک سطر ازکوئری را برمی گرداند. اگر کوئری هیچ "
"نتیجه ای نداشت،``None`` را برمی گرداند. بعداً از :meth:`~sqlite3.Cursor."
"fetchall` استفاده می شود که فهرستی از همه نتایج را برمی گرداند."

#: ../../tutorial/views.rst:207
msgid ""
":func:`~werkzeug.security.check_password_hash` hashes the submitted password "
"in the same way as the stored hash and securely compares them. If they match, "
"the password is valid."
msgstr ""
":func:`~werkzeug.security.check_password_hash` رمز عبور ارسالی را همانند هش "
"ذخیره شده هش می کند و به طور ایمن آنها را با هم مقایسه می کند. اگر مطابقت "
"داشته باشند، رمز عبور صحیح است."

#: ../../tutorial/views.rst:211
msgid ""
":data:`session` is a :class:`dict` that stores data across requests. When "
"validation succeeds, the user's ``id`` is stored in a new session. The data "
"is stored in a *cookie* that is sent to the browser, and the browser then "
"sends it back with subsequent requests. Flask securely *signs* the data so "
"that it can't be tampered with."
msgstr ""
":data:`session` یک :class:`dict است که داده ها را در بین درخواست ها ذخیره می "
"کند. هنگامی که اعتبارسنجی موفقیت آمیز بود، ``id`` کاربر در یک جلسه جدید ذخیره "
"می شود. داده‌ها در یک *کوکی* ذخیره می‌شوند که به مرورگر ارسال می‌شود و مرورگر آن "
"را با درخواست‌های بعدی باز می‌فرستد. فلاسک به طور ایمن داده ها را *امضا* می کند "
"تا نتوان آنها را دستکاری کرد."

#: ../../tutorial/views.rst:217
msgid ""
"Now that the user's ``id`` is stored in the :data:`session`, it will be "
"available on subsequent requests. At the beginning of each request, if a user "
"is logged in their information should be loaded and made available to other "
"views."
msgstr ""
"اکنون که ``id`` کاربر در :data:`session` ذخیره شده است، در درخواست‌های بعدی در "
"دسترس خواهد بود. در ابتدای هر درخواست، در صورتی که کاربری وارد شده باشد، باید "
"اطلاعات وی بارگذاری شده و در اختیار سایر نماها قرار گیرد."

#: ../../tutorial/views.rst:236
msgid ""
":meth:`bp.before_app_request() <Blueprint.before_app_request>` registers a "
"function that runs before the view function, no matter what URL is requested. "
"``load_logged_in_user`` checks if a user id is stored in the :data:`session` "
"and gets that user's data from the database, storing it on :data:`g.user "
"<g>`, which lasts for the length of the request. If there is no user id, or "
"if the id doesn't exist, ``g.user`` will be ``None``."
msgstr ""
":meth:`bp.before_app_request() <Blueprint.before_app_request>` تابعی را ثبت "
"می کند که قبل از تابع view اجرا می شود، مهم نیست چه URL درخواست شده است. "
"``load_logged_in_user`` بررسی می کند که آیا شناسه کاربری در :data:`session` "
"ذخیره شده است یا خیر و داده های آن کاربر را از پایگاه داده دریافت می کند و آن "
"را در :data:`g.user <g>` ذخیره می کند، که طول آن به مدت درخواست. اگر شناسه "
"کاربری وجود نداشته باشد، یا اگر شناسه وجود نداشته باشد، ``g.user`` برابر با "
"``None`` خواهد بود."

#: ../../tutorial/views.rst:246
msgid "Logout"
msgstr "خروج از حساب کاربری"

#: ../../tutorial/views.rst:248
msgid ""
"To log out, you need to remove the user id from the :data:`session`. Then "
"``load_logged_in_user`` won't load a user on subsequent requests."
msgstr ""
"برای خروج از سیستم، نیاز دارید که شناسه کاربری را از :data:`session` حذف "
"کنید. سپس ``load_logged_in_user`` در درخواست‌های بعدی کاربر را بارگیری نمی‌کند."

#: ../../tutorial/views.rst:261
msgid "Require Authentication in Other Views"
msgstr "نیاز احراز هویت در سایر نماها"

#: ../../tutorial/views.rst:263
msgid ""
"Creating, editing, and deleting blog posts will require a user to be logged "
"in. A *decorator* can be used to check this for each view it's applied to."
msgstr ""
"ایجاد، ویرایش و حذف پست‌های وبلاگ نیاز به ورود کاربر دارد. می‌توان از یک "
"*دکوراتور* برای بررسی این موضوع برای هر نما که روی آن اعمال می‌شود استفاده کرد."

#: ../../tutorial/views.rst:280
msgid ""
"This decorator returns a new view function that wraps the original view it's "
"applied to. The new function checks if a user is loaded and redirects to the "
"login page otherwise. If a user is loaded the original view is called and "
"continues normally. You'll use this decorator when writing the blog views."
msgstr ""
"این دکوراتور یک عملکرد نمای جدید را برمی‌گرداند که نمای اصلی را که روی آن "
"اعمال شده است، می‌پیچد. عملکرد جدید بررسی می کند که آیا کاربر بارگیری شده است "
"یا خیر و در غیر این صورت به صفحه ورود هدایت می شود. اگر کاربر بارگذاری شود "
"نمای اصلی فراخوانی می شود و به طور معمول ادامه می یابد. هنگام نوشتن نماهای "
"وبلاگ از این دکوراتور استفاده خواهید کرد."

#: ../../tutorial/views.rst:287
msgid "Endpoints and URLs"
msgstr "نقاط پایانی و URL ها"

#: ../../tutorial/views.rst:289
msgid ""
"The :func:`url_for` function generates the URL to a view based on a name and "
"arguments. The name associated with a view is also called the *endpoint*, and "
"by default it's the same as the name of the view function."
msgstr ""
"تابع :func:`url_for` یک نما را بر اساس نام و آرگومان ها تولید می کند. نام "
"مرتبط با یک ، *endpoint* نیز نامیده می شود و به طور پیش فرض با نام تابع view "
"یکی است."

#: ../../tutorial/views.rst:294
msgid ""
"For example, the ``hello()`` view that was added to the app factory earlier "
"in the tutorial has the name ``'hello'`` and can be linked to with "
"``url_for('hello')``. If it took an argument, which you'll see later, it "
"would be linked to using ``url_for('hello', who='World')``."
msgstr ""
"برای مثال، نمای ``hello()`` که قبلاً در آموزش به کارخانه برنامه افزوده شده "
"است، نام ``'hello'`` را دارد و می‌توان آن را با ``url_for('hello')`` پیوند "
"داد. اگر به آرگومان نیاز داشت، که بعداً خواهید دید، به استفاده از "
"``url_for('hello', who='World')``. پیوند داده می‌شود."

#: ../../tutorial/views.rst:300
msgid ""
"When using a blueprint, the name of the blueprint is prepended to the name of "
"the function, so the endpoint for the ``login`` function you wrote above is "
"``'auth.login'`` because you added it to the ``'auth'`` blueprint."
msgstr ""
"هنگام استفاده از یک طرح اولیه، نام طرح اولیه به نام تابع اضافه می شود، "
"بنابراین نقطه پایانی برای تابع «login» که در بالا نوشتید، ``'auth.login'`` "
"است زیرا آن را به طرح ``'auth'`` اضافه کردید."

#: ../../tutorial/views.rst:305
msgid "Continue to :doc:`templates`."
msgstr "با :doc:`templates` ادامه دهید."
