# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets
# This file is distributed under the same license as the Flask package.
# Komeil Parseh <ahmdparsh129@gmail.com>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: Flask 2.1.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-03-07 09:57+0330\n"
"PO-Revision-Date: 2022-04-06 18:28+0430\n"
"Last-Translator: Komeil Parseh <ahmdparsh129@gmail.com>\n"
"Language-Team: fa <ahmdparsh129@gmail.com>\n"
"Language: fa\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"
"X-Poedit-Bookmarks: -1,10,-1,-1,-1,-1,-1,-1,-1,-1\n"

#: ../../testing.rst:2
msgid "Testing Flask Applications"
msgstr "تست کردن برنامه های فلاسک"

#: ../../testing.rst:4
msgid ""
"Flask provides utilities for testing an application. This documentation goes over techniques for working "
"with different parts of the application in tests."
msgstr ""
"فلاسک ابزارهایی را برای آزمایش یک برنامه ارائه می دهد. این مستندات به تکنیک‌های کار با بخش‌های مختلف برنامه "
"در آزمایش‌ها می‌پردازد."

#: ../../testing.rst:8
msgid "We will use the `pytest`_ framework to set up and run our tests."
msgstr "ما از فریمورک `pytest`_ برای تنظیم و اجرای تست های خود استفاده خواهیم کرد."

#: ../../testing.rst:16
msgid ""
"The :doc:`tutorial </tutorial/index>` goes over how to write tests for 100% coverage of the sample Flaskr "
"blog application. See :doc:`the tutorial on tests </tutorial/tests>` for a detailed explanation of specific "
"tests for an application."
msgstr ""
"بخش :doc:`آموزش </tutorial/index>` به نحوه نوشتن تست برای پوشش۱۰۰ درصدی نمونه برنامه وبلاگ Flaskr می "
"پردازد. برای توضیح دقیق تست‌های خاص برای یک برنامه، به :doc:`آموزش تست ها </tutorial/tests>` مراجعه کنید."

#: ../../testing.rst:23
msgid "Identifying Tests"
msgstr "شناسایی تست ها"

#: ../../testing.rst:25
msgid ""
"Tests are typically located in the ``tests`` folder. Tests are functions that start with ``test_``, in "
"Python modules that start with ``test_``. Tests can also be further grouped in classes that start with "
"``Test``."
msgstr ""
"تست‌ها معمولاً در پوشه ``tests`` قرار دارند. تست ها توابعی هستند که با ``test_`` شروع می شوند در ماژول هایی "
"که اول آنها نیز ``test_`` دارند شروع میشوند. همچنین می‌توان تست ها را در کلاس‌هایی که با ``Test`` شروع می‌شوند "
"گروه‌بندی کرد."

#: ../../testing.rst:29
msgid ""
"It can be difficult to know what to test. Generally, try to test the code that you write, not the code of "
"libraries that you use, since they are already tested. Try to extract complex behaviors as separate "
"functions to test individually."
msgstr ""
"دانستن اینکه چه چیزی را باید آزمایش کنید ممکن است دشوار باشد. به طور کلی، سعی کنید کدهایی را که می نویسید "
"تست کنید، نه کد کتابخانه هایی که استفاده می کنید، زیرا قبلاً آزمایش شده اند. سعی کنید رفتارهای پیچیده را به "
"عنوان توابع جداگانه استخراج کنید تا به صورت جداگانه آزمایش کنید."

#: ../../testing.rst:36
msgid "Fixtures"
msgstr "فیکسچرس(Fixtures)"

#: ../../testing.rst:38
msgid ""
"Pytest *fixtures* allow writing pieces of code that are reusable across tests. A simple fixture returns a "
"value, but a fixture can also do setup, yield a value, then do teardown. Fixtures for the application, test "
"client, and CLI runner are shown below, they can be placed in ``tests/conftest.py``."
msgstr ""
"Pytest *fixtures* اجازه می دهد تا قطعات کدی را بنویسید که در تست ها قابل استفاده مجدد هستند. یک فیکسچر ساده "
"یک مقدار را برمی‌گرداند، اما یک فیکسچر همچنین می‌تواند راه‌اندازی کند، مقداری تولید کند و سپس خرابی را انجام "
"دهد. وسایل مربوط به برنامه، سرویس گیرنده آزمایشی و اجراکننده CLI در زیر نشان داده شده است، آنها را می توان "
"در ``tests/conftest.py`` قرار داد."

#: ../../testing.rst:44
msgid ""
"If you're using an :doc:`application factory </patterns/appfactories>`, define an ``app`` fixture to create "
"and configure an app instance. You can add code before and after the ``yield`` to set up and tear down "
"other resources, such as creating and clearing a database."
msgstr ""
"اگر از یک :doc:`Application Factory </patterns/appfactories>` استفاده می کنید، برای ایجاد و پیکربندی یک "
"نمونه برنامه، فیکسچر ``app`` را تعریف کنید. می‌توانید قبل و بعد از ``yield`` کد اضافه کنید تا منابع دیگر "
"مانند ایجاد و پاک کردن پایگاه داده را تنظیم و از بین ببرید."

#: ../../testing.rst:50
msgid ""
"If you're not using a factory, you already have an app object you can import and configure directly. You "
"can still use an ``app`` fixture to set up and tear down resources."
msgstr ""
"اگر از کارخانه استفاده نمی کنید، از قبل یک شی برنامه دارید که می توانید مستقیماً آن را وارد و پیکربندی کنید. "
"همچنان می‌توانید از یک ``app`` برای راه‌اندازی و از بین بردن منابع استفاده کنید."

#: ../../testing.rst:84
msgid "Sending Requests with the Test Client"
msgstr "درخواست با کلاینت تست"

#: ../../testing.rst:86
msgid ""
"The test client makes requests to the application without running a live server. Flask's client extends :"
"doc:`Werkzeug's client <werkzeug:test>`, see those docs for additional information."
msgstr ""
"کلاینت تست بدون اجرای یک لایو سرور درخواست هایی برای برنامه ایجاد میکند. کلاینت تست فلاسک شامل :doc:"
"`Werkzeug کلاینت <werkzeug:test>` است که برای اطلاعات بیشتر میتوانید به اسناد آن مراجعه کنید."

#: ../../testing.rst:91
msgid ""
"The ``client`` has methods that match the common HTTP request methods, such as ``client.get()`` and "
"``client.post()``. They take many arguments for building the request; you can find the full documentation "
"in :class:`~werkzeug.test.EnvironBuilder`. Typically you'll use ``path``, ``query_string``, ``headers``, "
"and ``data`` or ``json``."
msgstr ""
"``client`` دارای روش هایی است که با روش های رایج درخواست HTTP، مانند ``client.get()`` و ``client.post()`` "
"مطابقت دارد. آنها استدلال های زیادی را برای ایجاد درخواست می گیرند. می توانید مستندات کامل را در :class:"
"`~werkzeug.test.EnvironBuilder` بیابید. معمولا از ``path`` ، ``query_string`` ، ``headers`` ، ``data`` یا "
"``json``. استفاده میکنید."

#: ../../testing.rst:97
msgid ""
"To make a request, call the method the request should use with the path to the route to test. A :class:"
"`~werkzeug.test.TestResponse` is returned to examine the response data. It has all the usual properties of "
"a response object. You'll usually look at ``response.data``, which is the bytes returned by the view. If "
"you want to use text, Werkzeug 2.1 provides ``response.text``, or use ``response.get_data(as_text=True)``."
msgstr ""
"برای درخواست، روشی را که درخواست باید از آن استفاده کند با مسیر مسیری که باید آزمایش کند، فراخوانی کنید. "
"یک :class:`~werkzeug.test.TestResponse` برای بررسی داده های پاسخ بازگردانده می شود. تمام خصوصیات معمول یک "
"شی پاسخگو را دارد. شما معمولاً به ``response.data`` نگاه می کنید، که بایت های بازگردانده شده توسط view است. "
"اگر می‌خواهید از متن استفاده کنید، ``response.get_data(as_text=True)`` را ارائه می دهد، یا از نیز میتوانید "
"استفاده کنید."

#: ../../testing.rst:111
msgid ""
"Pass a dict ``query_string={\"key\": \"value\", ...}`` to set arguments in the query string (after the ``?"
"`` in the URL). You can also pass a string if you want to set a specific value directly."
msgstr ""
"برای تنظیم آرگومان ها در رشته کوئری (بعد از ``?`` در URL) یک دستور ``query_string={\"key\": \"value\"، ...}"
"`` ارسال کنید. همچنین اگر می‌خواهید مقدار خاصی را مستقیماً تنظیم کنید، می‌توانید یک رشته را ارسال کنید."

#: ../../testing.rst:115
msgid "Pass a dict to ``headers={}`` to set request headers."
msgstr "برای تنظیم هدر های درخواست یک دیکشنری به ``headers={}`` ارسال کنید."

#: ../../testing.rst:117
msgid ""
"To send a request body in a POST or PUT request, pass a value to ``data``. If raw bytes are passed, that "
"exact body is used. Usually, you'll pass a dict to set form data."
msgstr ""
"برای ارسال بدنه درخواست در یک درخواست POST یا PUT، یک مقدار را به ``data`` ارسال کنید. اگر بایت های خام "
"ارسال شوند، دقیقاً از آن متن استفاده می شود. معمولاً برای تنظیم داده‌های فرم یک دستور ارسال می‌کنید."

#: ../../testing.rst:123
msgid "Form Data"
msgstr "فرم داده"

#: ../../testing.rst:125
msgid ""
"To send form data, pass a dict to ``data``. The ``Content-Type`` header will be set to ``multipart/form-"
"data`` or ``application/x-www-form-urlencoded`` automatically."
msgstr ""
"برای ارسال فرم داده، یک دیکشنری به ``data`` ارسال کنید. هدر ``Content-Type`` به صورت خودکار روی ``multipart/"
"form-data`` یا ``application/x-www-form-urlencoded`` automatically تنظیم می‌شود."

#: ../../testing.rst:129
msgid ""
"If a value is a file object opened for reading bytes (``\"rb\"`` mode), it will be treated as an uploaded "
"file. To change the detected filename and content type, pass a ``(file, filename, content_type)`` tuple. "
"File objects will be closed after making the request, so they do not need to use the usual ``with open() as "
"f:`` pattern."
msgstr ""
"اگر یک مقدار برای آپلود فایل ها برای خواندن بایت های آن فایل(در مود ``\"rb\"`` ) تلقی شود. برای تغییر نام "
"فایل های شناسایی شده و نوع محتوا، یک تاپل ``(file, filename, content_type)`` را ارسال کنید. اشیای فایل پس "
"از درخواست بسته خواهند شد بهمین دلیل نیز به استفاده از الگوی ``with open() as f:`` نیازی نیست."

#: ../../testing.rst:135
msgid ""
"It can be useful to store files in a ``tests/resources`` folder, then use ``pathlib.Path`` to get files "
"relative to the current test file."
msgstr ""
"ذخیره فایل ها در پوشه ``tests/resources`` و سپس استفاده از ``pathlib.Path`` برای دریافت فایل های مربوط به "
"فایل های آزمایشی میتواند مفید باشد."

#: ../../testing.rst:155
msgid "JSON Data"
msgstr "داده های JSON"

#: ../../testing.rst:157
msgid ""
"To send JSON data, pass an object to ``json``. The ``Content-Type`` header will be set to ``application/"
"json`` automatically."
msgstr ""
"برای ارسال داده های JSON، یک شی را به ``json`` ارسال کنید. هدر ``Content-Type`` به طور خودکار روی "
"``application/json`` تنظیم می شود."

#: ../../testing.rst:160
msgid ""
"Similarly, if the response contains JSON data, the ``response.json`` attribute will contain the "
"deserialized object."
msgstr ""
"به طور مشابه، اگر پاسخ حاوی داده‌های JSON باشد، ویژگی ``response.json`` حاوی شی غیر سریالایز شده خواهد بود."

#: ../../testing.rst:182
msgid "Following Redirects"
msgstr "دنبال کردن ریدایرکت ها"

#: ../../testing.rst:184
msgid ""
"By default, the client does not make additional requests if the response is a redirect. By passing "
"``follow_redirects=True`` to a request method, the client will continue to make requests until a non-"
"redirect response is returned."
msgstr ""
"به طور پیش فرض، اگر پاسخ یک ریدایرکت باشد، کلاینت درخواست اضافی نمی کند. با دور زدن "
"``follow_redirects=True`` برای یک روش درخواست، کلاینت به درخواست‌ها ادامه می‌دهد تا زمانی که یک پاسخ "
"غیرمستقیم برگردانده شود."

#: ../../testing.rst:189
msgid ""
":attr:`TestResponse.history <werkzeug.test.TestResponse.history>` is a tuple of the responses that led up "
"to the final response. Each response has a :attr:`~werkzeug.test.TestResponse.request` attribute which "
"records the request that produced that response."
msgstr ""
":attr:`TestResponse.history <werkzeug.test.TestResponse.history>` دارای چندین پاسخ است که به پاسخ نهایی "
"منجر شده است. هر پاسخ دارای ویژگی :attr:`~werkzeug.test.TestResponse.request` است که درخواستی را که آن پاسخ "
"را ایجاد کرده است، ثبت می کند."

#: ../../testing.rst:205
msgid "Accessing and Modifying the Session"
msgstr "دسترسی به و اصلاح جلسه"

#: ../../testing.rst:207
msgid ""
"To access Flask's context variables, mainly :data:`~flask.session`, use the client in a ``with`` statement. "
"The app and request context will remain active *after* making a request, until the ``with`` block ends."
msgstr ""
"معمولا برای دسترسی به متغیر های زمینه فلاسک از :data:`~flask.session` در کلاینت با عبارت ``with`` استفاده  "
"می‌شود. برنامه و زمینه درخواست **بعد از** درخواست تا پایان بلوک ``with`` فعال می‌ماند."

#: ../../testing.rst:224
msgid ""
"If you want to access or set a value in the session *before* making a request, use the client's :meth:"
"`~flask.testing.FlaskClient.session_transaction` method in a ``with`` statement. It returns a session "
"object, and will save the session once the block ends."
msgstr ""
"اگر می‌خواهید به جلسه *قبل از* درخواست دسترسی داشته باشید یا مقداری تنظیم کنید، از متد :meth:`~flask.testing."
"FlaskClient.session_transaction` کلاینت را در عبارت ``with`` استفاده کنید. یک شی جلسه را برمی گرداند و پس "
"از پایان بلوک، جلسه را ذخیره می کند."

#: ../../testing.rst:248
msgid "Running Commands with the CLI Runner"
msgstr "اجرای دستورات با CLI Runner"

#: ../../testing.rst:250
msgid ""
"Flask provides :meth:`~flask.Flask.test_cli_runner` to create a :class:`~flask.testing.FlaskCliRunner`, "
"which runs CLI commands in isolation and captures the output in a :class:`~click.testing.Result` object. "
"Flask's runner extends :doc:`Click's runner <click:testing>`, see those docs for additional information."
msgstr ""
":meth:`~flask.Flask.test_cli_runner` برای ایجاد :class:`~flask.testing.FlaskCliRunner` ارائه میدهد که این "
"دستورات CLI را به صورت مجزا اجرا می‌کند و خروجی را در یک شی :class:`~click.testing.Result` می‌گیرد. برای "
"اطلاعات بیشتر درباره Runner فلاسک میتوانید :doc:`Click's runner <click:testing>` را ببینید."

#: ../../testing.rst:256
msgid ""
"Use the runner's :meth:`~flask.testing.FlaskCliRunner.invoke` method to call commands in the same way they "
"would be called with the ``flask`` command from the command line."
msgstr ""
"از متود :meth:`~flask.testing.FlaskCliRunner.invoke` برای فراخوانی دستورات به همان روشی که با دستور "
"``flask`` که از خط فرمان فراخوانی میشوند، استفاده کنید."

#: ../../testing.rst:278
msgid "Tests that depend on an Active Context"
msgstr "تست هایی که به یک زمینه فعال بستگی دارند"

#: ../../testing.rst:280
msgid ""
"You may have functions that are called from views or commands, that expect an active :doc:`application "
"context </appcontext>` or :doc:`request context  </reqcontext>` because they access ``request``, "
"``session``, or ``current_app``. Rather than testing them by making a request or invoking the command, you "
"can create and activate a context directly."
msgstr ""
"شما ممکن است توابعی داشته باشید که از نماها یا دستورات فراخوانی می شوند، که انتظار دارند :doc:`request "
"context  </reqcontext>` یا :doc:`application context </appcontext>` فعال باشد زیرا به ``request`` ، "
"``session`` یا ``current_app`` دسترسی دارند. به جای آزمایش آنها با درخواست یا فراخوانی دستور، می توانید "
"مستقیماً یک زمینه ایجاد و فعال کنید."

#: ../../testing.rst:287
msgid ""
"Use ``with app.app_context()`` to push an application context. For example, database extensions usually "
"require an active app context to make queries."
msgstr ""
"از ``with app.app_context()`` برای فشار دادن زمینه یک برنامه استفاده کنید. به عنوان مثال، پسوندهای پایگاه "
"داده معمولاً به یک زمینه برنامه فعال برای ایجاد پرس و جو نیاز دارند."

#: ../../testing.rst:297
msgid ""
"Use ``with app.test_request_context()`` to push a request context. It takes the same arguments as the test "
"client's request methods."
msgstr ""
"از ``with app.test_request_context()`` برای فشار دادن زمینه درخواست استفاده کنید. همان آرگومان‌هایی را "
"می‌گیرد که روش‌های درخواست مشتری آزمایشی هستند."

#: ../../testing.rst:311
msgid ""
"Creating a test request context doesn't run any of the Flask dispatching code, so ``before_request`` "
"functions are not called. If you need to call these, usually it's better to make a full request instead. "
"However, it's possible to call them manually."
msgstr ""
"ایجاد زمینه درخواست آزمایشی هیچ یک از کدهای ارسال فلاسک را اجرا نمی کند، بنابراین توابع ``before_request`` "
"فراخوانی نمی شوند. اگر به آنها نیاز دارید آنها را فراخوانی کنید، معمولاً بهتر است تا به جای آن یک درخواست "
"کامل ارائه دهید. با این حال، امکان فراخوانی دستی با آنها وجود دارد."
